# 📚 스터디 템플릿

## 📖 1. 목차를 읽기 전에 든 생각
- 실시간으로 순위를 갱신하려면 어떤 데이터 구조나 알고리즘을 사용할까?

## 📝 2. 내용 정리
### 개략적 규모 추정
- 사용자 점수 획득 QPS : 50 * 10 * 5 = 2,500
- 상위 10명 순위표 가져오기 QPS : 50

### API 설계
1. 사용자의 순위를 갱신
2. 순위표에서 상위 10명의 플레이어를 가져옴
3. 특정 사용자의 순위를 가져옴

### 개략적 설계안
- 사용자가 게임하는 게임 서비스와 순위표 서비스가 존재한다.

#### 클라이언트가 순위표 서비스와 직접 통신해야 하나?
- 대안 중 하나는 클라이언트가 점수를 정하는 방식
    - 중간자 공격때문에 보안상 안전하지 않음
- 점수는 서버가 설정해야함

#### 게임 서비스와 순위표 서버 사이에 메시지 큐가 필요한가?
- 해당 데이터가 다른 곳에서도 이용되거나 여러 기능을 지원해야 하면 카프카에 데이터를 넣는 것이 합리적

### 데이터 모델

1. 관계형 데이터베이스 :
    - 사용자가 많지 않으면 관계형 데이터베이스를 이용할 가능성이 높다.
    - 레코드가 수백만개 정도로 많아지면 성능이 너무 나빠지는 문제가 있다.
        - 사용자의 순위를 파악하려면 모든 플레이어를 순위표의 정확한 위치에 정렬해야한다.
        - 지속적으로 변화하는 대량의 정보를 신속하게 처리하지 못한다.
        - 실시간성을 요구해 캐시 도입도 불가능하다.
2. Redis :
    - 메모리 기반 키-값 저장소 시스템으로 빠른 읽기 및 쓰기가 가능하다.
    - 정렬 집합이라는 자료형을 제공한다.
        - 집합과 유사한 알고리즘

### 저장소 요구사항
- 사용자 ID와 점수를 저장해야한다.
- 2,500만명 사용자가 한번씩 승리해 모두 월간 순위표에 올라야하는 상황이 최악의 시나리오이다.
    - 이때 650MB의 저장공간이 레디스 캐시에 필요하다.
    - 이정도라면 스킵 리스트 구현에 필요한 오버헤드와 정렬 집합 해시를 고려해 메모리 사용량을 두 배로 늘린다고 해도 최신 레디스 서버 한대만으로도 데이터를 충분히 저장할 수 있다.
- CPU와 I/O 사용량도 고려해야한다.
    - 단일 레디스 서버로도 충분히 감당할 수 있는 부하이다.
- 데이터의 영속성도 고려해야한다.
    - 레디스는 데이터를 디스크에 영속적으로 보관하는 옵션도 지원한다.
    - 하지만 재시작하려면 시간이 오래걸린다. 그래서 읽기 사본을 두는 식으로 구성한다.

### 클라우드 서비스 사용 여부
- 솔루션 배포 방식은 일반적으로 두가지로 나눌 수 있다.
1. 자체 서비스를 이용하는 방안 :
    - 해당 기간의 순위표를 저장한다.
    - 이름 및 프로필 이미지와 같은 사용자 세부 정보는 MySQL 데이터베이스에 저장한다.
    - 순위표를 가져올 때 API 서버는 순위 데이터와 더불어 데이터베이스에 저장된 사용자의 이름과 프로필 이미지도 가져온다.
2. 클라우드 서비스를 이용하는 방안 :
    - API 게이트웨이를 사용하면 RESTful API의 HTTP 엔드포인트를 정의하고 아무 백엔드 서비스에나 연결할 수 있다.

### 레디스 규모 확장
- 규모가 커지면 샤딩이 필요하다.
1. 고정 파티션 :
    - 순위표에 등장하는 점수의 범위에 따라 파티션을 나누는 방안
    - 점수가 고르게 분포되어있어야 제대로 작동이 가능
    - MySQL 질의를 통해 사용자의 현재 점수를 계산하여 알아내는 것도 한 가지 방법
2. 해시 파티션 :
    - 레디스 클러스터를 사용하는 것으로, 사용자들의 점수가 특정 대역에 과도하게 모여 있는 경우에 효과적
    - 레디스는 여러 노드에 데이터를 자동으로 샤딩하는 방법을 제공
    - 각각의 키가 특정한 해시 슬롯에 속하도록 하는 샤딩 기법을 사용
    - 샤드에서 많은 데이터를 읽고 또 정렬해야하므로 지연 시간이 늘어나고, 가장 느린 파티션에서 데이터를 다 읽고 나서야 질의 결과를 계산할 수 있으므로 지연 시간이 길어진다.

- 고정 파티션을 사용한다.

### NoSQL
- 대안이 될 만한 다른 한가지 솔루션은 NoSQL
- 이유 :
    1. 쓰기 연산에 최적화 되어있다.
    2. 같은 파티션 내의 항목을 점수에 따라 효율적으로 정렬 가능하다.
- 순위표와 사용자 테이블을 비정규화한다고 가정 순위표를 화면에 표시하는 데 필요한 모든 정보를 담고있다고 가정
    - 레코드가 많아지면 상위 점수를 찾기위해 전체 테이블을 뒤져야 하므로 성능이 떨어진다.
    - game_name을 파티션 키로, 점수를 정렬 키로 사용하면 된다.
    - 이방법은 부하가 높을때 문제이다.
- n개 파티션으로 분할하고 파티션 번호를 파티션 키에 추가하는 것이 바람직하다.


## 💡 3. 전부 읽고 난 후기
- 실시간 순위표를 구현할 때 단순히 점수를 저장하는 것이 아니라, 빠른 조회와 정렬을 위한 데이터 구조가 중요하다는 점이 흥미로웠다.

## ❓ 4. 특별히 궁금했던 부분
- 게임별로 별도의 순위표를 유지해야 하는 경우, 데이터 모델을 어떻게 설계하는 것이 효율적일까?