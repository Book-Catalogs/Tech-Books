# 📚 스터디 템플릿

## 📖 1. 목차를 읽기 전에 든 생각
- 블록체인인가?
- 실제 계좌와 차이가 무엇일까?

## 📝 2. 내용 정리
### API 설계
1. 이체 API
- 해당 장에서는 하나의 API만 구비하면 된다.

### 인메모리 샤딩
- <사용자, 잔액>을 인메모리 저장소에 저장하는것이 좋다.
- 레디스 노드는 한대로 100만 TPS 처리하기 벅차다.
- 설정 전문 저장소인 주키퍼를 사용해 레디스 노드의 파티션 수 및 주소를 저장해둔다.
- 지갑서비스 2개 노드, 클라이언트 3개 노드로 나누어져있을때 만약 A -> B로 1달러 이체라는 명령을 받으면 A, B가 연결된 지갑 서비스가 A, B에 두개의 명령을 전달한다.

### 데이터베이스 샤딩
- 두개의 저장소 노드를 갱신하는 연산을 원자적으로 수행하려면 레디스 노드를 트랜잭션을 지원하는 관계형 DB 노드로 교체할 수 있다.
  - A B C 잔액 정보가 레디스 노드가 아닌 3개의 관계형 DB 노드로 분산
  - 첫번째 서버와 두번째 서버가 동시에 갱신되도록 하려면 어떻게 해야할까?
- 2단계 커밋
  - 저수준 방안 : 데이터베이스 자체에 의존하는 방안. 2단계 커밋이 사용됨
    1. 조정자가 여러 데이터베이스에 읽기 및 쓰기 작업을 수행 -> 그 결과 데이터 베이스 A와 C에는 락이 걸림
    2. 트랜잭션을 커밋하려할때 조정자는 모든 DB에 트랜잭션 준비
    3. 위 단계에서 조정자는 모든 데이터베이스의 응답을 받아 모든 DB가 예라고 응답하면 커밋 요청, 한 DB라도 아니오를 응답하면 DB 트랜잭션을 중단한다.
    - 하지만 락이 오랫동안 잠긴 상태로 남을 수 있어 성능에 좋지않다.
  - 분산 트랜잭션 TC/C(고수준 방안) : 두 단계로 구성된 보상 트랜잭션
    1. 조정자는 모든 DB에 트랜잭션을 필요한 자원 예약 요청
    2. 조정자는 모두 에라고 응답하면 모든 DB에 작업 확인을 요청하는데 이것이 시도-확정 절차임
    3. 어느 하나라도 아니오라고 응답하면 DB에 작업 취소 요청하는데 이것이 시도-취소 절차임

### 2PC와 TC/C 비교
- 2PC : 두 번째 단계가 시작될 때 모든 로컬 트랜잭션이 완료되지 않은 상태
- TC/C : 두번째 단계가 시작될 때 모든 로컬 트랜잭션이 완료된 상태 실행 취소 절차를 비즈니스 로직으로 구현하므로 구수준 해결방법

### 단계별 상태 테이블
- TC/C 실행 도중 지갑 서비스가 다시 시작되면 과거 모든 작업 기록이 사라진다.
  - 해결책 : TC/C의 진행 상황, 특히 각 단계 상태 정보를 트랜잭션 데이터베이스에 저장하면 된다.

### 불균형 상태
- TC/C 방식에서는 시도 단계가 끝나면 계정 A에서 1달러가 차감되지만 계정 C에는 변화가 없어 전체 잔액이 줄어드는 불균형이 발생할 수 있다.
- TC/C는 여러 개의 독립적인 로컬 트랜잭션으로 구성되며, 애플리케이션이 중간 결과를 직접 확인하고 처리해야 한다.
- 분산 트랜잭션과 달리 TC/C에서는 실행 도중 데이터 불일치가 발생할 수 있으며 이를 애플리케이션이 직접 해결해야한다

### 유효한 연산 순서
- 시도 단계에서 가능한 세 가지 연산 중 두 번째와 세번째 선택지는 유효하지 않다
- 두 번째 선택지에서는 계정 C에 돈이 추가된 후 계정 A에서 차감이 실패하면 취소 전에 C에게 돈이 인출될 위험이 있다.
- 세 번째 선택지에서는 A에서 차감과 C에서 추가를 동시에 수행할 경우 A에서 차감이 실패하면 C에만 돈이 추가되는 문제가 발생할 수 있다.

### 사가
- 사가는 마이크로서비스 아키텍처에서 표준적인 분산 트랜잭션 솔루션으로 모든 연산을 순서대로 실행하고 각각 독립적인 로컬 트랜잭션으로 수행된다.
- 연산이 실패하면 실패한 연산부터 처음 연산까지 역순으로 보장 트랜잭션을 실행하여 롤백한다.
- 따라서 n개의 연산을 실행하는 분산 트랜잭션은 보상 트랜잭션까지 포함해 총 2n개의 연산이 필요하다

### TC/C vs 사가
- 모두 애플리케이션 수준의 분산 트랜잭션 방식이고 각 방식의 차이점은 420p에 정리되어있다.
- 실무에서 어떤 방식을 선택할지는 지연 시간 요구사항에 따라 달라진다.
  - 지연시간이 중요하지 않고 서비스 수가 적다면 어느것을 사용해도 괜찮지만 마이크로서비스 아키텍처에서는 사가를 선호함
  - 지연 시간이 중요한 경우에는 TC/C가 적합

### 이벤트 소싱
- 금융 시스템에서는 과거 계정 잔액을 조회하거나 코드 변경 후 시스템 로직의 올바름을 검증해야 할대가 있다.
- 이를 효과적으로 처리하기 위해 이벤트 소싱 기법이 사용된다.
1. 명령 :
   - 외부에서 전달되는 명확한 요청
   - 순서가 중요하여 FIFO 큐에 저장
2. 이벤트 :
   - 명령이 실행된 결과로 발생하는 기록
   - 명령과 달리 과거의 사실이며 검증된 상태를 나타냄
   - 이벤트는 명령의 순서를 따라 FIFO 큐에 저장
3. 상태 :
   - 이벤트가 적용될 때 변경되는 값
   - 계좌의 상태를 저장하는 방식으로 맵또는 키값 저장소를 사용할 수 있음
4. 상태 기계
   - 이벤트 소싱에서는 상태 기계를 사용하여 프로레스를 관리
   - 명령의 유효성 검사 및 이벤트 생성
   - 이벤트를 적용하여 상태 갱신

### 지갑 서비스 예시
- 명령 : 지갑 서비스에서 이체 요청이 명령이 됨
- 카프카와 같은 메시지 큐를 사용하여 명령을 순서대로 저장 및 처리
- 계정 잔액은 관계형 DB에 저장
- 명령 -> 유효성 검사 -> 이벤트 생성 -> 상태 갱신 구조로 동작

### 재현성
1. 기존 DB의 한계
   - 계정 잔액만 저장 -> 변경된 이유 추적이 어려움
   - 과거 잔액을 확인할 수 없음 -> 특정 시점의 상태 복원 불가능
2. 이벤트 소싱의 장점
   - 모든 상태 변경을 이벤트 형태로 기록 -> 과거 이벤트를 재생하면 언제든 상태 복원 가능
   - 불변한 이벤트 리스트로 인해 데이터 위변조 방지

### CQRS
- 이벤트 소싱의 문제점 : 클라이언트가 계정 잔액을 직접 알기 어려움
- CQRS의 해결 방법 :
  - 상태를 직접 제공하는 대신 이벤트 자체를 외부에 공개
  - 외부 시스템이 이벤트를 받아 직접 상태를 계산하도록 설계
- CQRS의 특징 :
  - 상태 기록 담당 시스템과 상태 조회 담당 시스템 분리

### 파일 기반의 명령어 및 이벤트 목록
- 로컬 디스크에 저장하는 방안은 네트워크를 통한 전송 시간을 피할 수 있음
- HDD에서도 잘 작동함
- 최근 명령과 이벤트를 메모리에 캐시하는 방법도 존재. 다시 로드하지 않다도 됨
  
### 파일 기반 상태
- 잔액 정보를 관계형 DB에 저장했지만 프로덕션 환경에서는 네트워크를 통해서만 접근 가능한 독립형 서버에서 DB를 실행
- 파일 기반 로컬 관계형 DB인 SQLite를 사용하거나 로컬 파일 기반 키-값 저장소를 사용할 수 있음

### 스냅숏
- 재현성은 상태 기계로 하여금 이벤트를 항상 처음부터 다시 읽도록 하는 것임
- 그냅숏을 사용하면 더이상 최초 이벤트에서 시작할 필요가 없다.
- 스냅숏은 거대한 이진 파일이며 HDFS과 같은 객체 저장소에 저장

### 신뢰성 분리
- 데이터가 손실되면 복원할 방법이 없음
- 이벤트 목록의 신뢰성만 보장하면 상태와 스탭숏을 언제든 만들 수 있음
- 이벤트 생성은 난수나 외부 입출력 등이 무작위적 요소가 포함될 수 있음. 따라서 명령의 신뢰성 만으로는 이벤트의 재현성을 보장할 수 없음
- 이벤트는 과거의 사실임. 불변이고 상태 재구성에 사용할 수 있음

### 합의
- 안정성을 제공하려면 이벤트 목록을 여러 노드에 복제해야함
- 래프트 알고리즘을 예로 최대 하나의 노드만 클러스터의 리더가 되고 나머지 노드는 괄로어가 되도록 함
  
### 풀vs푸시
- 풀 모델 : 외부 사용자가 읽기 전용 상태 기계에서 주기적으로 실행 상태를 읽음. 실시간이 아니고 주기를 너무 짧게 설정하면 지갑 서비스에 과부하가 걸릴 수 있음
- 푸시 모델 : 읽기 전용 상태 기계로 이벤트를 수신하자마자 실행 상태를 역방향 프락시에 푸시하도록 한다면 사용자에게 실시간으로 응답이 이루어지는 느낌을 줄 것임

### 분산 트랜잭션
- 동기적 실행 모델을 채택하면 TC/C나 사가 같은 분산 트랜잭션 솔루션을 재사용할 수 있음

## 💡 3. 전부 읽고 난 후기
- 생각보다 많은 기술들이 들어가있구나

## ❓ 4. 특별히 궁금했던 부분
- TC/C와 사가가 무엇인지 정확히 이해가 되지 않네요...ㅠㅠ
