# 📚 스터디 템플릿

## 📖 1. 목차를 읽기 전에 든 생각
- 보안과 규제 준수를 위한 아키텍처 설계가 어떻게 이루어질까?
- 대규모 사용자를 지원하기 위한 분산 시스템 구조가 필요할까?

## 📝 2. 내용 정리
### 개략적 규모 추정
- QPS : 215,000

### 개략적 설계안
- 중요경로를 따라 흐르는 모든 정보는 신속하게 처리되어야 한다.
- 고객 주문 -> 브로커가 주문을 거래소에 전송 -> 클라이언트 게이트웨이를 통해 거래소로 들어감 -> 유효성 검사, 속도 제한, 인증, 정규화 같은 기본적인 게이트 키핑 기능 수행 => 위험성 점검 -> 주문 처리자금이 충분한지 확인 -> 체결엔진이 매수 측과 매도측에서 두개의 집행 기록을 생성 -> 주문 집행 사실을 클라이언트에 전송

### 시퀀서
- 체결 엔진을 결정론적으로 만드는 핵심 구성 요소이다.
- 입력 시퀀서와 출력 시퀀서 두 가지가 있고 각각 고유한 순서를 유지한다. 시퀀서가 만드는 순서 ID는 누락된 항목을 쉽게 발견할 수 있는 일련번호여야 한다.
- 메시지 큐 역할도 한다.

### 주문 관리자
- 한쪽에서는 주문을 받고 다른 쪽에서는 집행기록을 받는다.
- 위험 점검 담당 컴포넌트에 주문을 보내 위험성 검토 -> 충분한 자금이 있는지 확인 -> 주문을 시퀀서에 전달의 역할을 한다
- 시퀀서를 통해 체결 엔진으로부터 집행 기록을 받는다.

### 클라이언트 게이트웨이
- 지연 시간에 민감하다.
- 고객 유형별 클라이언트 게이트웨이는 다양하다.

### 시장 데이터 흐름
- 체결 엔진에서 집행 기록을 수신하고 집행 기록 스트림에서 호가 창과 봉 차트를 만들어 낸다.
- 시장 데이터가 데이터 서비스로 전송되어 해당 서비스의 구독자가 사용할 수 있게 된다.

### 보고 흐름
- 거래의 중요 경로상에 있지는 않지만 중요한 시스템이다.
- 거래 이려그 세금 보고, 규정 준수 여부 보고 결산 등의 기능을 제공한다.

### 데이터 모델
- 상품, 주문, 집행 :
    - 상품 데이터는 자주 변경되지 않는다.
        - 아무 데이터베이스에나 저장 가능하며, 캐시를 적용하기 좋다.
    - 주문은 매수 또는 매도를 실행하라는 명령이며 집행 기록은 체결이 이루어진 결과이다. 주문과 집행 기록은 거래소가 취급하는 가장 중요한 데이터이다.
        - 성능을 높이기위해 메모리에서 거래를 체결하고 하드디스크나 공유 메모리를 활용하여 주문과 집행 기록을 저장하고 공유한다.
        - 주문과 집행 기록은 빠른 복구를 위해 시퀀서에 저장하고 데이터 보관은 장 마감 후에 실행한다.
        
### 호가 창
- 효율성이 높은 것이어야한다.
    - 일정한 조회 시간
    - 빠른 추가/취소/실행 속도
    - 빠른 업데이트
    - 최고 매수 호가/최저 매도 호가 질의
    - 가격 수준 순회
- 이중 리스트로 O(1)을 만든다.
    - 새 주문을 넣는다는것은 리스트 마지막에 추가 : O(1)
    - 주문 체결은 맨처음 삭제 : O(1)
    - 주문 취소한다는 것은 Map을 사용하면 OrderId로 : O(1)

### 봉 차트
- 핵심 자료구조이다.
- 최적화 두가지 방법
    1. 미리 메로리를 할당해 둔 링 버퍼에 봉을 보관하면 새 객체 할당 횟수를 줄일 수 있다.
    2. 메모리에 두는 봉의 개수를 제한하고 나머지는 디스크에 보관한다.

### 성능
- 지연 시간은 거래소에 아주 중요한 문제이다.
- 지연 시간을 줄이는 방법에는 두 가지가 있다.
    1. 중요 경로에서 실행할 작업 수를 줄인다.
        - 게이트웨이 -> 주문관리자 -> 시쿼서 -> 체결엔진으로 꼭 필요한 구성 요소만 둔다.
    2. 각 작업의 소요 시간을 줄인다.
        - 네트워크 및 디스크 접근 시간을 고려하여 저지연 시스템 설계한다.
        - 모든 구성 요소를 단일 서버에 배치하여 불필요한 네트워크 통신을 줄인다.

### 이벤트 소싱
- 데이터베이스는 현재 상태만 유지한다.
- 변경하는 모든 이벤트의 변경 불가능한 로그를 유지한다.
- 주문 상태를 변경하는 모든 이벤트를 추적하므로 모든 이벤트를 순서대로 재생하면 주문 상태를 복수할 수 있다.
- 카프카의 펍/섭 구조와 비슷하다.
- 이벤트 소싱 아키텍처를 따르게 되면 모든 메시지는 동일한 이벤트 저장소를 사용한다.
    - 각 이벤트 저장소에는 하나의 시쿼서만 있다.
    - 시퀀서가 여러개 있으면 이벤트 저장소에 쓰는 권한을 두고 경쟁하게 되어 좋지 않다.

### 고가용성
- 거래소가 다운될 수 있는 시간은 하루에 8.64초를 넘으며 안된다.
- 주 인스턴스를 다중화해야 한다.
- 백업 인스턴스로의 장애 조치 결정이 빨라야 한다.
- 무상태 서비스의 경우 서버를 추가하면 쉽게 수평적 확장이 가능하다.
- 이벤트 소싱 아키텍처는 거래소에 적합하다.
    - 결정론적 특성 때문에 상태 복구가 쉽고 정확하기 때문이다.

### 결함 내성
- 부 서버까지 전부 다운되면 시명적이다.
- 여러 지역의 데이터 센터에 복제하여 이 문제를 해결한다.
- 처음엔 수동으로 데이터가 축적되면 자동으로 장애를 감지하고 복구하는 프로세스를 도입할것이다.
- 리더 선출 알고리즘은 래프트로 진행한다.
    - 리더는 팔로어에게 박동 메시지를 보낸다.
    - 일정 기간동안 박동 메시지를 받지 못한 팔로어는 새 리더를 선출한다.
    - 가장 먼저 선거 타이머가 타임아웃된 팔로어는 후보가 되고 다른 나머지 팔로어에게 투표를 요청한다.
    - 과반수 이상의 표를 받으면 새로운 리더가 된다.
    - 팔로어의 임기 값이 새 노드보다 짧으면 리더X 여러 명의 팔로어가 동시에 후보가 되는 경우는 분할 투표를 한다.
- 다운되어도 사업에 심각한 피해가 없는 시간의 최댓값이 복구 시간
    - 증권 거래소의 경우 2등급을 달성해야 한다.
    - 서비스의 자동 복구가 반드시 가능해야 한다.
    - 최소 서비스 수준을 유지하기 위한 성능 저하 전략을 사용한다.
- 복구 지점 목표는 비즈니스에 심각한 피해가 발생하기 전에 손실될 수 있는 데이터의 양, 손실 허용 범위를 의미한다.
    - 데이터는 자주 백업해야한다.
    - 증권 거래소에서 데이터 손실을 용납할 수 없어 0에 가깝다.
    - 래프트 매커니즘을 사용하면 데이터 사본은 많다

### 체결 알고리즘
- FIFO형태

### 결정론
- 기능적 결정론 : 시퀀서나 이벤트 소싱 아키텍처를 도입함으로써 이벤트를 동일한 순서로 재생하면 항상 같은 결과를 얻을 수 있도록 보장한다.
    - 이벤트가 발생하는 실제 시간은 중요하지 않다.
    - 중요한건 순서이다. 복구에 소요되는 시간이 크게 줄어든다.
- 지연시간 결정론 : 각 거래의 처리 시간이 거의 같다는 뜻이다.
    - 사업에서 가장 중요한 부분
    - 지연 시간 변동 폭이 커지면 원인을 조사해야한다.

### 시장 데이터 계시 서비스 최적화
- 링 버퍼 사용한다.
- 객체를 생성하거나 삭제하는 연산은 필요없다.

### 멀티 캐스트
1. 유니캐스트 : 하나의 출처에 하나의 목적지
2. 브로드캐스트 : 하나의 출처에서 전체 하위 네트워크
3. 멀티캐스트 : 하나의 출처에서 다양한 하위 네트워크 상의 호스트

- 거래서 설계에는 멀티캐스트를 사용한다.
- UDP를 사용하는데 이건 신뢰성이 낮아 재전송을 처리하는 방안이 필요하다.

### 네트워크 보안
- DDoS 공격에 대응할 수 있는 능력을 갖추는 것이 중요하다.
1. 공개 서비스와 비공개 서비스를 분리하여 DDoS 공격이 가장 중요한 클라이언트에 영향을 미치지 않도록 한다.
2. 자주 업데이트되지 않는 데이터는 캐싱한다.
3. URL을 강화한다.
4. 효과적인 허용/차단 리스트 메커니즘을 사용한다.
5. 처리율 제한 기능을 활용한다.

## 💡 3. 전부 읽고 난 후기
- 고가용성과 결함 내성을 위해 지역별 데이터 센터 복제 및 리더 선출 알고리즘을 활용하는 부분이 흥미로웠다.

## ❓ 4. 특별히 궁금했던 부분
-
