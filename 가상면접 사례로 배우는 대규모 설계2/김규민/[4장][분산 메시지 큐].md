# 📚 스터디 템플릿

## 📖 1. 목차를 읽기 전에 든 생각
- Kafka와 RabbitMQ의 차이점
- 분산 메시지 큐는 어떤 경우에 필요한가?

## 📝 2. 내용 정리
### 전통적 메시지 큐와 이벤트 스트리밍 플랫폼의 차이
1. RabbitMQ와 같은 전통적인 메시지 큐는 보관 문제를 중요하게 다루지 않는다.
2. 전달 순서도 보존하지 않는다.

### 메시지 모델
1. 일대일 모델
    - 메시지 큐에서 흔히 발견되는 모델이다.
    - 발행된 메시지는 오직 한 소비자만 가져갈 수 있다. -> 누군가가 가져가면 메시지큐에서 삭제된다.

2. 발행-구독 모델
    - 메시지를 주제별로 정리하는 토픽이 접목된 모델이다.

> 토픽, 파티션, 브로커 : 메시지는 토픽에 보관하는데, 서버 한 대로 감당하기 힘든 데이터의 양이다. 때문에 파티션, 즉 샤딩 기법을 활용하는 것이다. 주피커와 같은 브로커를 통해 파티션이 유지된다.

> 소비자 그룹 : 소비자 그룹 내 소비자는 토픽에서 메시지를 소비하기 위해 서로 협력한다. 소비자 그룹내에 소비자들은 같은 파티션을 구독하지 못한다.

<br>

### 개략적 설계안
1. 클라이언트 : 생산자, 소비자그룹
2. 핵심 서비스 및 저장소 : 브로커, 저장소, 조정 서비스, 아파치 주키퍼

### 상세 설계
1. 데이터 저장소
    - 메시지 큐의 트래픽 패턴
        - 읽기와 쓰기가 빈번하게 일어난다.
        - 갱신/삭제 연산은 발생하지 않는다
        - 순차적인 읽기/쓰기가 대부분이다.

> 선택지 1번 : 데이터베이스 : 저장 요구사항을 맞출 순있지만 읽기 연산과 쓰기 연산이 빈번하게 동시에 일어나는 대규모 서비스에서는 부적합하다.

> 선택지 2번 : 쓰기 우선 로그 : WAL은 새로운 항목이 추가되기만 하는 일반 파일이다. 지속성을 보장해야하면 WAL을 추천한다. 

2. 메시지 자료 구조
    - 메시지 자료 구조는 생산자, 메시지 큐, 소비자 사이의 계약이다.

> 메시지 키 : 키를 통해 파티션에 연결되고 만약 키값이 없다면 무작위 파티션에 연결된다.

> 메시지 값 : 페이로드를 말하고 메시지 값은 텍스트일수도 압축된 이진 블록일 수도 있다.

> 메시지의 기타 필드 : 토픽, 파티션, 오프셋, 타임스탬프, 크기, CRC 등등이 존재한다.

3. 일괄 처리
    - 생산자, 소비자, 메시지 큐는 메시지를 가급적 일괄 처리한다.
        - 운영체제로 하여금 여러 메시지를 한 번의 네트워크 요청으로 전송할 수 있도록 하기 때문에 값비싼 네트워크 왕복 비용을 제거할 수 있다.
        - 브로커가 여러 메시지를 한 번에 로그에 기록하면 더 큰 규모의 순차 쓰기 연산이 발생하고 운영체제가 관리하는 디스크 캐시에 더 큰 규모의 연속된 공간을 점유하게 된다. -> 더 높은 디스크 접근 대역폭을 달성할 수 있다.

4. 생산자 측 작업 흐름
    - 어느 브로커에 연결해야할지는 라우팅 계층을 도입해야 한다.
    - 리더와 사본을 이용해 브로커는 메시지를 관리한다.
        - 장애 감내가 가능한 시스템을 만들기위해 리더와 사본을 필요로 한다.
        - 단점 : 라우팅 계층을 도입하면 거쳐야 할 네트워크 노드가 하나 더 늘어나고, 일괄 처리가 가능하면 효율을 많이 높일 수 있지만 대부분 그 부분을 고려하지 않는다.
    -> 라우팅 계층을 생산자 내부로 편입시키고 버퍼를 도입한다.
        - 네트워크를 거칠 필요가 줄어들고 생산자는 메시지를 어느 파티션으로 보낼지 결정하는 자신만의 로직을 가질 수 있다.

5. 푸시 vs 풀
**푸시**
    - 장점 : 낮은 지연
    - 단점 : 소비자가 메시지 처리하는 속도가 생산자가 메시지를 만드는 속도보다 느리면 소비자에게 큰 부하가 걸릴 가능성이 있고, 생산자가 데이터 전송 속도를 좌우하므로, 소비자는 항상 그에 맞는 처리가 가능한 컴퓨팅 자원을 준비해 두어야한다.

**풀**
    - 장점 : 소비하는 속도는 소비자가 알아서 결정하고 메시지를 소비하는 속도가 생산 속도보다 느려지면 소비자를 늘려 해결할 수도 있다. 그리고 일괄처리에 적합하다.
    - 단점 : 브로커에 메시지가 없어도 소비자는 계속 데이터를 끌어가려 시도할 것이다.

-> 결론적으로 풀 모델을 지원한다.

6. 소비자 재조정
    - 어떤 소비자가 어떤 파티션을 책임지는지 다시 정하는 프로세스이다.
    - 코디네이터가 중요한 역할을 한다.
    - 그룹에 전담 코디네이터가 있고 코디네이터는 소비자 목록을 유지한다. 그리고 이 목록에 변화가 생기면 코디네이터는 해당 그룹의 새 리더를 선출하고 새 리더는 새 파티션 배치 계획을 만들고 코디네이터에게 전달하면 해당 계획을 그룹 내 다른 모든 소비자에게 알린다.

7. 상태 저장소
    - 소비자에 대한 파티션의 배치 관계, 소비자 그룹이 각 파티션에게 마지막으로 가져간 메시지의 오프셋을 저장하는 저장소이다.

8. 메타데이터 자장소
    - 토픽 설정이나 속성 정보를 보관한다.
    - 높은 일관성을 요구한다 이런 데이터의 보관에는 주키퍼가 적절하다.
-> 주키퍼 : 계층적 키-값 저장소 기능을 제공하는, 분산 시스템에 필수적인 서비스이다.

9. 복제
    - 하드웨어 장애는 흔한 일이므로 무시해선 안된다.
    - 디스크에 손상이나 영구적 장애가 발생하면 데이터는 사라지기때문에, 복제를 많이 사용한다.
    - 서로 레플리카와 샤드처럼 나뉘어 복제되어있다.

10. 사본 동기화
    - 어떤 한 노드의 장애로 메시지가 소실되는 것을 막기 위해 메시지는 여러 파티션에 두며, 각 파티션은 다시 여러 사본으로 복제한다.
    - 메시지는 리더로만 보내고 다른 단순 사본은 리더에서 메시지를 가져가 동기화한다.
    - ACK=all : 리더도 받고 동기화 되어야하는 방법으로 가장 느리다.
    - ACK=1 : 리더만 받으면 된다.
    - ACK=0 : 그냥 수신 확인하지 않는다 그래서 소실되도 retry를 진행하지 않는다.

11. 규모 확장성
    - 생산자 : 그룹 단위 조정에 가담할 필요가 전혀 없기 때문에 간단하다. 생산자의 규모 확장성은 새로운 생산자를 추가하거나 삭제함으로써 쉽게 달성할 수 있다.
    - 소비자 : 소비자 그룹은 서로 독립적이라 새 소비자 그룹은 쉽게 추가하고 삭제가 가능하다. 하지만 같은 소비자 그룹 내의 소비자가 새로 추가/삭제되거나 장애로 제거되어야 하는 경우는 재조정 메커니즘이 맡아 처리해야한다.
    - 브로커 : 브로커 노드가 추가되거나 삭제될 때 사본을 재배치 한다. 하지만 브로커 컨트롤러로 하여금 한시적으로 시스템에 설정된 사본 수보다 많은 사본을 허용하는게 더 나은 방법이다.
    - 파티션 : 파티션 수의 조정은 생산자와 소비자의 안전성에는 영향을 끼치지 않는다.

12. 메시지 전달 방식
    - 최대한 한 번 : 소실되더라도 다시 전달되는 일은 없다.
    - 최소 한 번 : 메시지가 한 번 이상 전달될 수 있으나 메시지 소실은 발생하지 않는 전달 방식이다. ACK=1 또는 ACK=all을 이용한 구성방식이다.
    - 정확히 한 번 : 구현하기 가장 까다로운 방식으로 사용자 입장에서는 편하지만 큰 대가를 지불해야한다.
    

## 💡 3. 전부 읽고 난 후기
- 푸시 모델과 풀 모델의 장단점 비교에서 풀 모델이 적합하다고 판단된 이유를 깊이 이해할 수 있었다.
- 메시지 큐의 설계가 단순한 메시지 전달 이상의 복잡한 구조와 과정을 포함한다는 점이 인상적이었다.

## ❓ 4. 특별히 궁금했던 부분
- Long Polling이 서버에 예상보다 많은 과부하를 초래한다고 하는데, 푸시 모델의 단점보다 풀 모델의 단점이 더 적은 이유는 무엇인가요?