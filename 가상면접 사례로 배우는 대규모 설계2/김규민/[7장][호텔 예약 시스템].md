# 📚 스터디 템플릿

## 📖 1. 목차를 읽기 전에 든 생각
- 호텔 예약 시스템에는 어떠한 기술이 필요할까?
- 동시성 문제에 대해서는 어떻게 풀고있을까?

## 📝 2. 내용 정리
### 개략적 규모 추정
1. 호텔/객실 상세 페이지 : QPS = 300
2. 예약 상세 정보 페이지 : QPS = 30
3. 객실 예약 페이지 = QPS = 3

### API 설계
**호텔 관련**
1. 호텔의 상세 정보 변환
2. 신규 호텔 추가. (호텔 직원만 사용 가능)
3. 호텔 정보 갱신. (호텔 직원만 사용 가능)
4. 호텔 정보 삭제. (호텔 직원만 사용 가능)

**객실 관련**
1. 객실 상세 정보 변환
2. 신규 객실 추가. (호텔 직원만 사용 가능)
3. 객실 정보 갱신. (호텔 직원만 사용 가능)
4. 객실 정보 삭제. (호텔 직원만 사용 가능)

**예약 관련**
1. 로그인 사용자의 예약 이력 반환
2. 특정 예약의 상세 정보 반환
3. 신규 예약
4. 예약 취소

### 데이터 모델
- 시스템 규모가 크진않음. 하지만 대규모 이벤트가 있는 경우에는 트래픽이 급증할 수 있으니 대비해야함.

1. 관계형 DB : 
    - 읽기 빈도가 쓰기 연산에 비해 높은 작업 흐름을 잘 지원한다.
    - ACID을 보장한다. ACID는 예약 시스템을 만드는 경우 중요하다.
    - 데이터를 쉽게 모델링할 수 있다.
2. NoSQL :
    - 대체로 쓰기연산에 최적화 되어있다.
    
> 관계형 DB를 사용하는것이 좋아보인다.

### 개략적 설계안
- 마이크로서비스 아키텍처를 사용한다.

### 개선된 데이터 모델
- 특정 객실이 아니라 특정 객실 유형을 예약하게된다. 때문에 호출인자는
```JSON
{
    "startDate": "2021-04-28",
    "endDate": "2021-04-30",
    "hotelID": "245",
    "roomTypeID": "U12345673389",
    "reservationID": "1322445"
}
```
와 같이 바뀌어야한다.

- 저장 용량의경우에는 5,000개의 호텔 20개의 객실유형이있다고 가정하면, 5,000 * 20 * 2년 * 365일 = 7300만 개 정도가 된다. 하나의 서버를 두기에는 SPOF 문제를 피할 수 없다. 

### 동시성 문제
1. 같은 사용자가 예약 버튼을 여러 번 누를 수 있다.
    - 클라이언트 측 구현
        - 예약버튼을 비활성화 시킨다.
    - 멱등 API
        - API 요청에 멱등 키를 추가하는 방안이다. 몇번을 호출해도  같은 결과를 내는 API를 멱등 API라고 부른다.
        - 1. 예약 세부정보 입력 후 예약 계속 버튼을 누르면 예약 주문을 생성
        - 2. 예약 주문서 반환. 이때 식별자인 reservation_id를 넘김
        - 3-1. 검토가 끝난 예약을 전송
        - 3-2. 사용자가 예약 완료 버튼을 한 번 더 누르면 reservation_id인 식별자로 유일 조건에 위반되어 레코드가 생성되지 않도록 함
2. 여러 사용자가 같은 객실을 동시에 예약하려 할 수 있다.
    - 비관적 락
        - 사용자가 레코드를 갱신하려고 하는 순간 즉시 락을 걸어 동시 업테이트를 방지하는 기술
        - 해당 레코드를 갱신하려는 다른 사용자는 먼저 락을 건 사용자가 변경을 마치고 락을 해제할 떄까지 기다려야함
        - 장점 : 애플리케이션이 변경 중이거나 변경이 끝난 데이터를 갱신하는 일을 막을 수 있다. 구현이 쉽고 연산을 직렬화하여 충돌을 막는다.
        - 단점 : 여러 레코드에 락을 결면 교착 상태가 발생할 수 있다. 확장성이 낮다.
        - 권장 X
    - 낙관적 락
        - 버전 번호와 타임스탬프의 두가지 방법으로 구현
        - 비관적 락보다 빠름
        - 사용자가 레코드를 읽고 레코드를 갱신할때 애플리케이션은 버전 번호에 1을 더한 다음 데이터베이스에 다시 기록. 이때 유효성 검사를 진행한다. 다음 버전 번호는 현재 버전 번호보다 1만큼 큰 값이어야 함. 이 유효성 검사가 실패하면 트랜잭션은 중단됨
        - 장점 : 애플리케이션이 유효하지 않은 데이터를 편집하는 일을 막는다. 데이터베이스 자원에 락을 걸 필요가 없다.
        - 단점 : 데이터에 대한 경쟁이 치열한 상황에서는 성능이 좋지 못하다.
        - 적합한 선택지
    - 데이터베이스 제약 조건
        - 낙관적 락과 아주 유사함
        - 장점 : 구현이 쉽다. 데이터에 대한 경쟁이 심하지 않을 때 잘 동작한다.
        - 단점 : 낙관적 락과 마찬가지로 데이터에 대한 경쟁이 심하면 성능이 좋지 못하다. 데이터베이스 제약 조건은 애플리케이션 코드와 달라서 버전을 통제하기 어렵다.

### 캐시가 주는 새로운 과제
- 캐시 계층을 추가하면 시스템의 확장성과 처리량은 대폭 증가하지만 데이터베이스와 캐시 사이의 데이터 일관성을 유지하는 도전에 직면하게 된다.

1. 잔여 객실 수를 질의하여 충분한지 확인한다.
2. 잔여 객실 데이터를 갱신한다.

- 잔여 객실 데이터에 대한 변화는 데이터베이스에 먼저 반영해 캐시에는 최신 데이터가 없을 가능성이 있다.
- 장점 : 읽기 질의를 캐시가 처리하므로 데이터베이스의 부하가 크게 줄어든다. 읽기 질의를 메모리에서 실행하므로 높은 성능을 보장할 수 있다.
- 단점 : 데이터베이스와 캐시 사이의 데이터 일관성을 유지하는 것은 어려운 문제이다.

### 서비스 간 데이터 일관성
- 모노리스 아키텍처의 경우 데이터의 일관성을 보장하기 위해 관계형 데이터베이스를 공유하는 것이 보통이다.
- 본 설계안에서 예약 서비스가 예약 및 잔여 객실 API를 모두 담당하는 마이크로서비스 기반 아키텍처를 채택했고, 예약 테이블과 잔여 객실 테이블을 동일한 관계형 데이터베이스에 저장하는 하이브리드 접근법을 택했다.
- 관계형 데이터베이스의 ACID 속성을 활용하여 예약 처리 과정에서 발생하는 많은 동시성 문제를 효과적으로 처리할 수 있다.

## 💡 3. 전부 읽고 난 후기
- 비관적 락과 낙관적 락에대해 이야기만 들어봤지 무엇인지 찾아볼 기회가 없었는데, 이번 기회로 비관적 락과 낙관적 락에대해 알 수 있었다.

## ❓ 4. 특별히 궁금했던 부분
- 본 설계안은 QPS가 크지않아 낙관적락이 적합하다고 판단했지만, 호텔 예약 시스템의 특성상 경쟁이 치열한 시간대에는 낙관적 락도 성능 저하가 발생할텐데 이때는 어떠한 대한을 고려할 수 있을까?