# 📚 스터디 템플릿

## 📖 1. 목차를 읽기 전에 든 생각

- 분산 메시지 큐는 무엇인가?

## 📝 2. 내용 정리

##### 메시지 큐의 장점

- 결합도 완화 : 컴포넌트 사이의 강한 결합을 끊을 수 있음
- 규모 확장성 개선 : 생산자 / 소비자 간 트래픽 부하에 맞기 조절 가능 
- 가용성 개선 : 특정 컴포넌트에 장애가 나도 다른 컴포넌트는 큐와 상호작용을 할 수 있음
- 성능 개선 : 비동기 통신이 가능하기에 서로 기다릴 필요가 없음

##### 메시지 모델

point to poitnt 모델 vs pub - sub 모델

point to point - 큐에 전송된 메시지는 오직 한 소비자만 가져갈 수 있음

pub - sub - 메시지를 토픽을 통해 주고 받을 수 있음

##### 토픽, 파티션, 브로커

토픽에 보관되는 양이 많은 경우 보통 샤딩기법을 활용 (파티션)

브로커 : 파티션을 유지하는 서버.

생산자가 보낸 메세지는 해당 토픽의 파티션들 중 하나로 보내짐.

- 만약 키가 있는 경우 같은 키를 가진 모든 메세지는 같은 파티션으로 보내짐
- 키가 없는 경우 무작위로 선택된 파티션으로 보내짐 

##### 푸시 vs 풀

푸시 모델

- 낮은 지연 : 브로커는 메세지를 받는 즉시 소비자에게 보낼 수 있음
- 소비자의 처리속도가 느릴 경우 소비자에게 부담이 될 수 있음
- 생산자가 데이터의 처리 속도를 좌우하므로, 소비자는 처리가 가능한 컴퓨팅 자원을 준비해 두어야 함

풀 모델 

- 메시지를 소비하는 속도를 소비자가 결정
- 일괄처리에 적합함
- 브로커에 메시지가 없어도 계속 데이터를 가져가려 함. -> Long Pulling 방식으로 보완

##### ISR (동기화 된 사본)

-> 성능과 영속성 사이의 타협점

ACK = all 

생산자는 모든 ISR이 동기화 된 후에 ACK 응답을 받음. 응답 시간이 길어지지만 영속성 측면에서는 가장 좋은 구성

ACK = 1

리더가 메시지를 저장하고 나면 바로 ACK 응답을 받음. 하지만 ACK 응답을 받은 직후 리더에 장애가 생기면 복구할 방법이 없음

ACK = 0 

보낸 메시지에 대한 수신 확인 메시지를 기다리지 않고 ACK 응답을 보내며 어떠한 재시도 를 하지 않음.

메시지 전달 방식

- 최대 한번 
  - 메시지가 전달 과정에서 소실되더라도 다시 전달 되는 일은 없음
  - 생산자는 토픽에 비동기적으로 메시지를 보내고 수신 응답을 기다리지 않음
- 최소 한번 
  - 같은 메시지가 한번 이상 전달도리 수는 있으나, 메시지 소실은 발생하지 않음
  - ACK = all 혹은 ACK = 1의 구성을 이용.

## 💡 3. 전부 읽고 난 후기

- kafka, rabbit MQ같은 서비스도 결국은 서버로 구성된 어플리케이션이구나

## ❓ 4. 특별히 궁금했던 부분

- 지속성을 보장해야 하는 메시지의 경우 왜 WAL에 보관하는 것을 추천 하는 지 ? 
  - 데이터 손실 방지
    - 데이터 변경 사항을 먼저 영구 저장소에 기록한 후 실제 DB에 반영
      - 만약 시스템이 갑작스럽게 중단되더라도 복구가 가능
  - 원자성 보장 
    - WAL은 데이터 변경작업을 하나의 트랜잭션 단위로 처리 => 일관성 유지 가능 
  - 쓰기 성능 향상
    - 데이터를 기록하는 방식 : 순차적 디스크 I/O -> 속도가 빠름