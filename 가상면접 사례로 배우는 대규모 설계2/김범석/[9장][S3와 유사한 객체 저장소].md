# 📚 스터디 템플릿

## 📖 1. 목차를 읽기 전에 든 생각

- 

## 📝 2. 내용 정리

저장소 시스템

- 블록저장소
  - 서버에 물리적으로 연결되는 형태의 드라이브
  - 원시 블록을 서버에 볼륨 형태로 제공하는 방식
- 파일저장소
  - 블록저장소 위에 구현됨
  - 데이터는 계층적으로 구성되는 디렉터리 안에 보관됨
- 객체저장소
  - 모든 데이터를 수평적 구조 내에 객체로 보관
  - 데이터 접근의 경우 RESTful API를 사용

데이터 라우팅 서비스

- 데이터 노드 클러스터에 접근하기 위한 RESTful 혹은 gRPC 서비스를 제공함
- 더 많은 서버를 추가해 쉽게 규모를 확장할 수 있는 무상태 서비스

배치 서비스

- 어느 데이터 노드에 데이터를 저장할 지 결정하는 역할을 담당
- 가상 클러스터 지도를 유지함 -> 클러스터의 물리적 형상 정보가 보관됨
- 배치서비스는 모든 데이터 노드와 지속적으로 heartbeat를 주고받으며 상태를 모니터링 함

데이터 노드 

- 실제 객체 데이터가 보관되는 곳
- 배치서비스와 주고 받는 heartbeat에 다음과 같은 정보들이 들어있음
  - 해당 데이터 노드에 부착된 디스크 드라이브의 수 
  - 각 드라이브에 저장된 데이터의 양

데이터의 저장 흐름

1. API 서비스는 객체 데이터를 데이터 저장소로 포워딩
2. 라우팅 서비스는 해당 객체에 UUID를 할당, 배치서비스에 보관할 데이터 노드를 질의
3. 데이터 라우팅 서비스는 저장할 데이터를 UUID와 함께 주 데이터 노드에 직접 전송
4. 주 데이터 노드는 데이터를 자기 노드에 지역적으로 저장 및 두개의 부 데이터 노드에 다중화
5. 객체의 UUID를 반환

데이터가 저장되는 방식

- 개별 파일로 저장
  - 작은 파일이 많아지면 성능이 떨어짐
  - 낭비되는 데이터 블록 수가 많아짐
    - 파일 시스템은 파일을 별도의 디스크 블록으로 저장 -> 아무리 작은 파일을 저장하더라도 4KB는 사용을 해야함
  - 아이노드 용량 한계 초과
    - 대부분의 파일 시스템의 경우 사용가능한 아이노드의 수는 디스크가 초기화 되는 순간에 결정됨
    - 작은 파일이 많아지면 아이노드가 전부 소진 될 가능성이 생김

- 작은 객체들을 큰 파일 하나로 모아서 저장
  - 객체 저장시 이미 존재하는 파일에 추가하는 방식으로 저장
  - 여러 CPU 코어가 쓰기 연산을 병렬로 진행하더라도 객체 내용이 뒤섞이지 않도록 주의가 필요함

객체 소재 확인

- 파일 기반 키 값 저장소 이용 (RodcksDB)
  - 쓰기 연산은 성능이 좋지만, 읽기 성능이 좋지 않음
- 관계형 DB
  - 쓰기 연산은 성능이 좋지 않지만, 읽기 성능이 좋음

소거 코드

- 데이터를 작은 단위로 분할해 다른 서버에 배치하는 한편, 그 가운데 일부가 소실되었을 때 복구하기 위한 패리티라는 정보를 만들어 중복성을 확보하는 방식

큰 파일의 업로드 성능 최적화

- 멀티파트 - 큰 객체는 작게 쪼갠다음 독립적으로 업로드하는 방식 
- 모든 조각이 업로드 되고 나면 객체 저장소는 그 조각을 모아 원본 객체를 복원함
- 조각 하나가 업로드 될 때 마다 데이터 저장소에서 ETag를 반환
- 모든 조각이 업로드 된 시점에 클라이언트는 ETag 목록을 보낸다.

## 💡 3. 전부 읽고 난 후기

- 

## ❓ 4. 특별히 궁금했던 부분

- 