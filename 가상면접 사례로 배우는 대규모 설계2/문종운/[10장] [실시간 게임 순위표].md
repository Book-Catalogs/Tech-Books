# 📚 스터디 템플릿

## 📖 1. 목차를 읽기 전에 든 생각
- 정말 상용적으로 많이 사용되고 있는 서비스이기에 먼저 재밌을 것 같다.
- 내가 만약에 실시간 게임 순위표를 구현한다면 나는 다음과 같이 구현 방식을 택할 것 같다. 
게임 순위표에 대한 데이터는 읽기 작업이 많다. 따라서, 매 시간마다 Read 작업을 하는 것은 많은 부하를 일으 킬 수 있다. 
Redis에는 SortedSet이 있으므로 분산 캐시를 활용하여 고객에 최고 점수만을 Redis에 반영하고 기존 점수의 누적 데이터는 DB에 적재한다.
Redis에서 조회하는 SortedSet의 데이터는 O(1) 이므로 부하가 적을 것이다. 혹은 정말 실시간이여야 하는가? 를 바탕으로 쿼리를 select max(score) ... group by (user_id) order by score를 하지 않을까. 그리고 이 결과는 Redis에 보관한다.

- 내 게임의 대한 순위와 점수가 바로 데이터에 보관됨을 확인 할 필요는 없다. 뒤에서 후처리 되도 된다. 점수 저장 및 연산 기능은 따로 이벤트 혹은 비동기로 처리해도 충분 할 듯 하다.
- 하지만, 이벤트로 처리한다면 두 가지 기능을 하나의 이벤트로 처리가 가능하다. 1. 점수 저장 2. 순위 반영 (단, 점수가 저장되기 이전에 순위가 반영되면 순위의 변동이 생길 수 있는 문제가 있다. 이 관점에서는 좋지 않은 것 같기도 함.)

## 📝 2. 내용 정리

### 기능 요구사항
- 순위표에 상위 10명의 플레이러를 표시
- 특정 사용자의 순위를 표시
- 어떠 사용자보다 4순위 위와 아래에 있는 사용자를 표시

### 비기능 요구사항
- 점수 업데이트는 실시간으로 순위표에 반영
- 일반적인 확장성, 가용성 및 안정성 요구사항

### 클라이언트의 점수 전달
- 클라이언트에서 점수를 반영하여 서버에 요청하는 방식은 중간자 공격으로 인해서 보안상 문제가 생길 수 있다.
- 따라서, 점수의 처리는 서버에서 처리하는 것이 중요하다.

### 데이터 모델
- 단순하게 생각해서 관계형 데이터베이스 쿼리를 통해서 내림차순으로 정렬하면 유저의 순위 점수를 반영 할 수 있다.
- 특히, 이 방식을 이용해서도 내 유저 상위 4명, 하위 4명을 뽑을 수 있는 쿼리도 작성 할 수 있다.
- 메모리에 전부 적재하고 id를 기반으로 찾거나, 자신의 점수를 기반으로 찾는 방식으로 가능하다.

**[단점]**
- 치명적인 단점이 있는데, 레코드의 수가 늘어나면 늘어날수록 성능이 떨어질 수 있고 메모리에 적재할 수 있는 양도 제한이 생기는 규모 확장성이 좋지 않다는 문제가 있다.
- 이를 위한 대안으로 Redis를 사용 할 수 있다.

### 레디스
- 레디스는 인메모리 분산 캐시 서비스로 적재되어 있는 데이터를 빠르게 조회 할 수 있다.
- 특히, 레디스에서는 Sorted Set을 활용하여 찾고자 하는 데이터를 빠르게 가지고 올 수 있다.

#### Sorted Set
- 레디스의 Sorted Set은 해시 테이블과 Skip list를 사용하고 있다.
- 해시 테이블로 Sorted Set이 구성이 되어 있더라도 다음 row를 찾기 위해서는 어느정도 linked list 형태로 접근을 해야 한다. 이에 대한 최적화를 위해서 depth를 두어 몇 개의 노드를 건너뛰어 탐색 할 수 있도록 하는 것이다.

```zsh
1 -> 5 -> 9 (2-depth)
1 -> 3 -> 5 -> 7 -> 9 (1-depth)
1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9

if (node.next > target):
  if (node.hasChild()):
    node = node.child
```
- Redis의 SortedSet은 상위 10명, 본인의 순위, 정렬 되어 있는 집합 관계에서 특정 범위의 데이터를 가져오는 모든 연산을 제공해주고 있다.

### 서버 설계

#### 자체 서버를 이용
- 우리가 평상시에 서버를 올리고 여러 Restful API를 프로토콜 통신을 통해서 처리하는 방식이다.
- 별도의 저장소(ex, MySQL, Redis)를 준비하고 요청이 들어 올 때마다 저장소와 네트워크 통신을 통해 적합한 데이터를 가지고 올 수 있을 것이다.

#### Serverless Faas 사용
- Serverless는 서버의 관리를 하지 않고 API 통신을 통해서만 처리 할 수 있는 방식이다.
- 실제 작성 된 코드에서는 어떠한 function 을 API Gateway에 전달하여 function을 업로드하고 AWS 람다 함수가 이벤트가 발생 할 때마다 이를 호출하여 실행한다.
- AWS 람다는 MySQL, Redis와 같은 인프라를 클라이언트에서 접근 할 수 있도록 열어주고 있기 떄문에 이 또한 적합하다.

### 레디스 규모 확장
게임이 너무 잘 되어서 DAU가 기하급수적으로 늘어나고 약 5억의 DAU를 처리해야 한다면 저장용량은 기하급수적으로 늘어난다. 이러한 용량은 한 대의 레디스에서 처리하기에는 부족하다. 따라서, 레디스 또한 샤딩이 필요하다.

#### 샤딩 방안
**[고정 파티션]**  
- 순위표에 등장하는 점수의 범위에 따라 파티션을 나눌 수 있다. (ex, 1..100, 101..200, 201..300, ...N..M)
- 위와 같은 형태는 빠르게 찾을 수 있지만 만약 핫스팟 문제가 발생하게 되면 이를 처리하기가 어려워진다.

**[해시 파티션]**  
- 어떠한 키를 기준으로 적절한 해시 슬롯을 가져 올 수 있도록 연산 작업을 처리하고 적절한 노드에 전달한다.
- 하지만, 위와 같은 방식은 특정 데이터가 어디에 적재되어 있는지를 찾기 위해서 모든 노드를 탐색 할 수 있는 가능성이 있다.

#### 노드 크기 조정
- Redis Benchmark와 같은 유틸을 이용하여 실제 Redis에 얼마나 부하가 발생하는지 부하 테스트를 진행 할 수 있다.
- 특히, 쓰기 작업이 같은 경우 데이터의 백업을 위한 스냅샷을 보관해야하기 때문에 기존 메모리보다 2배 높은 메모리를 사용하는 것이 권장된다.

### NoSQL 처리
- MongoDB, DynamoDB, 카산드라와 같은 NoSQL DB를 사용 할 수 있다.
- 해당 DB들은 데이터가 많아졌을 떄 partition key와 sorted key를 통해서 정렬 된 데이터를 찾아 낼 수 있다.
- 다만, 내부적으로 key-value 형태의 해시 테이블에 적재되는 것이기 때문에 카디널리티가 낮은 키를 partition key로 선택하면 value에서 탐색해야 할 데이터가 그 만큼 많기 때문에 탐색에 대한 성능이 떨어지므로 적절한 partition key를 선택하는 것이 중요하다.
- 이 부분에서는 적절한 트레이드 오프가 있어야 한다. 너무 카디널리티가 높은 키를 partition key를 하게 되면 분산되어 있는 데이터를 합쳐서 최종 순위표를 만드는 경우에 더 많은 비용이 발생 할 수 있기 때문이다.

## 💡 3. 전부 읽고 난 후기
- 운이 좋게도 이미 고민해봤던 경험이여서 초기에 고민했던 내용과 일치했던 부분이 있어 뿌듯하기도 하면서 재밌기도한 파트였다.
- 다만, 실제로 더 많은 대용량 데이터가 들어왔을 때 어떻게 샤딩처리를 할 것 인지에 대한 고민은 안해봤는데 해당 고민을 엿 볼 수 있어서 좋은 파트였다.
- 특히 serverless는 많이 들어봤는데, 별도의 함수를 어떻게 전달하는지에 대해서 여러 example을 찾아 볼 수 있는 기회였다.

## ❓ 4. 특별히 궁금했던 부분
- serverless는 사용 할 수 있는 인프라 자원이 어느정도 한정이 되어 있어서 local 기반으로 테스트 하기가 용이하지 않은데 offline serverless도 있다고 하네요. 다만 연결하는 부분을 살펴보니 serverless framework 를 사용해야 하고 이는 js 기반으로 되어있는 것 같았어요. 혹시 사용해보신 분 경험 공유가능한지..?
- 실제로 레디스 클러스터를 사용하고 있는데 위와 같은 상황은 없어서 저희는 해시 파티션으로 되어 있어요. 별도로 고정 파티션이 적용되어 있는 분?
