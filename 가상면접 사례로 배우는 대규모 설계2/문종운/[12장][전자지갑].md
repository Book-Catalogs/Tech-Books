# 📚 스터디 템플릿

## 📖 1. 목차를 읽기 전에 든 생각
- 음.. 전자지갑? 네이버 페이, 토스 페이 같은 것을 의미하는 건가?
- 궁금해서 잠깐 봤더니 서로 다른 계좌 간의 이체의 과정이다.
- 하나의 단일 트랜잭션에서 모든 계좌의 흐름을 처리 하는 것은 쉽지 않다. 동일한 서비스라면 동일한 서비스 내에서 단일 트랜잭션으로 정합성을 보장 할 수 있으나, 만약 다른 서버에 올라가있는 별개의 계좌라면 이미 분산 트랜잭션이 되어버린다.
- 이러한, 분산 트랜잭션에 상황 속에서 계좌 간의 흐름에서 어떻게 정합성을 유지 할 것인가에 대한 방법이 주된 내용을 이룰 것 같다. 

## 📝 2. 내용 정리

### 전자지갑
전자 지갑이라하여 잘 와닿지 않았지만, **블록 체인에서는 가상 서버에 있는 계좌 자체를 전자 지갑**이라고 부른다고 한다. 간단하게 애플리케이션과 내 통장이 연결되어 있는 계좌 시스템이라고 보자.

앞서 결제, 주문을 담당하는 시스템에서는 금액의 무결성이 중요하다. 특히, 각 언어별로 precision을 처리하는 방식이 다르기 때문에 적절한 자료형을 사용해야 한다.
여기서는, string형을 선택했는데 MySQL에는 Decimal이 있으니 잘 연결해보자. Varchar 라면 적절히 Converter를 만들어주는 것이 좋겠다.

### 인메모리 샤딩
계좌 처리를 위해 먼저 인메모리 레디스를 사용한다.
데이터를 저장하고, 읽는 방식에 있어서는 디스크 작업을 사용하지 않기 때문에 상대적으로 빠를 수 있으나 샤딩을 통해서 이체를 처리한다면 정확성 요구사항을 처리 할 수 없다.  
어느 애플리케이션이든 예상치 못하는 장애가 발생하고, 이체와 같은 금융 거래는 속도보다는 정확성이 제일 중요하다.

### 분산 트랜잭션
원자적인 트랜잭션을 처리하기 위해서 DB를 분리하고 각 트랜잭션의 정합성을 보장하기 위한 방법을 소개한다.  
분산 트랜잭션 처리는 저수준과 고수준으로 나누어지는데 저수준은 DB에 의존하는 것이고, 고수준은 애플리케이션 코드로 조절하는 것이다. 늘 그렇듯 고수준으로 갈수록 구현이 어렵지만 요구사항을 해결하기 용이하고  
저수준으로 갈수록 구현은 쉽지만 조절하기 어려운 문제들이 있다.

#### 2단계 커밋(2PC)
1. 조정자(자체 서비스)에서 먼저 락을 선점하고 업데이트 작업을 처리한다.
2. 트랜잭션이 가능한지 준비 명령을 보낸다. MySQL에서는 XA Prepare, START 와 같은 쿼리가 있다.
3. 조정자가 트랜잭션이 모두 가능한지를 응답받으면 그제서야 커밋을 하고 하나라도 안된다면 XA ROLLBACK 처리한다.

여기서 의문은 **2번에서 XA Prepare가 모두 가능하다고 했지만, 3번을 진행하는 과정에서 커밋을 실패하면 어떡하지?** 라는 고민이 들었다.  
[MySQL 공식문서](https://dev.mysql.com/doc/refman/8.4/en/xa-statements.html) 를 읽어보니 자체적으로 Failover 기능이 있었다. 실패하더라도 재시도를 통해 정합성을 보장해준다.  

하지만, 저수준의 분산 트랜잭션 처리이기 떄문에 락을 오래잡고 있으면 전체적인 시스템 성능은 저하되기 마련이다. 또한, SPOF 문제까지 일으킬 수 있다.

#### TC/C (Try-Confirm/Cancel)
2PC와 달리 고수준으로 처리하는 방식이다.  
**[시도 단계]**
- 조정자 역할을 하는 지갑 서비스가 두 개의 트랜잭션 명령을 두 개의 데이터베이스로 전송한다.
  - 즉, 두 개의 데이터베이스에는 각 계좌를 처리하기 위해 분산 되어있다.
  - A 이체, B NO_OP 명령을 수행한다.

**[확정 단계]**
- 만약, 위에서 실행한 두 개의 데이터베이스 요청이 성공한다면, 확정단계에 돌입한다.
  - 시도 단계에서는 A만 이체를 하고 C는 어떠한 작업도 하지 않았기에, 이제 C가 작업을 하고 A가 NO_OP를 진행하면 된다.
 
**[취소 단계]**
- 하지만, A만 성공하고 B가 준비되지 않은 상태일 수 있다.
  - 위와 같은 상황에는 A에 대한 작업을 다시 되돌려야 한다. 코드로는 잔액을 다시 돌려주어야 하는 것이다.

분산 트랜잭션에서 가장 중요한 부분은 트랜잭션의 진행 단계에 대한 추적과 백업이다. 이를 위해서, 분산 트랜잭션이 진행 할 때 분산 트랜잭션의 ID와 현재 진행 된 상태들을 명시해야 한다.

#### 분산 트랝잭션: 사가
마이크로서비스 아티켁처의 표준이며, 개념은 TC/C와 비슷하다. TC/C 또한 보상 트랜잭션 방식이기 때문이다.
1. 모든 연산은 순서대로 정려된다. 각 연산은 자기 데이터베이스에 독립 트랜잭션으로 실행된다.
2. 연산은 첫 번째부터 마지막까지 순서대로 실행된다. 한 연산이 완료되면 다음 연산이 개시된다.
3. 연산이 실패하면 전체 프로세스는 실패한 연산부터 맨 처음 연산까지 역순으로 보상 트랜잭션을 통해 롤백한다.

연산 실행 순서는 크게 두 가지가 있다.
1. 분산 조율(Choreography) : 모든 서비스가 다른 서비스의 이벤트를 구독하여 작업을 수행하는 방식이다.
2. 중앙 집중형 조율(Orchestration) : 하나의 조정자가 모든 서비스의 순서를 관리한다. 마치 TC/C와 유사하다.

제일 보기 쉬운 것은 코드이다. MSA 환경에서는 이벤트 기반으로 처리하는 경우가 많지만, 동기적인 작업을 수행해야 하는 경우도 많다.
```kotlin
fun invoke() {
  val orderItem = orderRepostiory.findById(orderId).findOrderItem(orderItemId);

  val product = productHttpClient.getProduct(orderItem.getProductId()); // 여기서 실패 할 수 있지만, 수정 작업이 없기에 보상 트랜잭션은 필요없다.

  stockHttpClient.decreaseStock(productId) { stockHttpClient.increaseStock(productId) }
}

// stockHttpClient
fun decreaseStock(productId: Long, rollbackAction: () -> Unit) {
  return try {
    httpClient.decrease(productId);
  } catch (e: Exception) {
    log...
    rollbackAction()
  }
}
```
하지만, 이 함수의 실행 전까지 하나의 함수만 들어온다고 장담을 할 수는 없다. 이전에 여러 개의 호출이 있었을 수 있다.

```kotlin
// stockHttpClient
fun decreaseStock(productId: Long, vararg rollbackActions: () -> Unit) {
  return try {
    httpClient.decrease(productId);
  } catch (e: Exception) {
    log...
    rollbackActions.forEarch {it()}
  }
}
```
이제 이렇게 하면 앞 전에 발생했던 성공했던 다른 트랜잭션에 대해서도 성공 할 수 있게 할 수 있다.
하지만, 보통 또 보상 트랜잭션은 보통 비동기로 처리하는 경우가 많다. catch 문에서 실행되는 행위를 관찰해야 하는가는 의문이다. 어쨋든 성공해야 한다. 하지만, 또 실패 할 수 있다.  
따라서, 보상 트랜잭션을 수행하는 상태 기계를 별도로 만들기는 한다. 이 형태는 TC/C 처럼 상태 기계를 Global Transaction을 만들어서 메세지 발행이 정상적으로 이루어졌는지 현재 Global Transaction이 성공했는지를 확인한다.

### TC/C vs SAGA
TC/C와 SAGA의 큰 차이는 선형적으로 진행되는가, 병렬적으로 진행되는가이다. 결국, 속도에 달려있다.  
요구사항에서 만약 지연시간에 대한 요구사항이 중요하지 않거나 서비스가 작다면 어떤 것도 선택해도 괜찮다. 하지만, **지연시간이 중요하다면 TC/C를 먼저 고려**해보자.

### 이벤트 소싱
이벤트 소싱에서는 가장 중요한 용어 4가지가 있다.
1. **명령(command)**
2. **이벤트(event)**
3. **상태(state)**
4. **상태 기계(state machine)**

#### 명령
**외부에서 전달된 의도가 명확한 요청** 이다. 여기서 핵심은 요청이라는 것이다. 명령은 어떻게든 가능하다. 현재 도메인의 상태는 어떠한지 중요하지 않다.

#### 이벤트
이벤트는 **명령 이행 결과**이다. 즉, 명령이 정상적으로 수행되었는가이다. **"정상"** 이라는 말이 중요한데, 유효성 검증을 실패한다면 해당 명령은 이벤트가 될 수 없는 것이다.  
이벤트는 **하나의 명령으로 여러 이벤트가 만들어질 수 있고, 같은 명령에 항상 동일한 이벤트들이 만들어진다는 보장 또한 없다.**

#### 상태
이벤트가 적용될 때 밴경되는 내용이다. key-value 구조의 어떤 형태로든 상태를 관리 할 수 있다.

#### 상태 기계
명령의 유효성을 검사하고 이벤트를 생성 하고 이벤트를 적용하여 상태를 갱신한다.

여기까지의 내용을 코드로 단순하게 살펴보자.
```kotlin
class Foo {
  private val commandQueue: Deque<FooEvent> = ArrayDeque()

  fun invoke() {
     val domain = do()..
     this.commandQueue.add(BaseFooEvent(domain))
  }

  fun pollAll(): List<FooEvent> {
    val events = mutableListOf<FooEvent>()
    while (commandQueue.isNotEmpty()) {
      commandQueue.pollFirst()?.let { events.add(it) }
    }
    return events
    }
}

class FooService(
  private val eventPublisher: EventPublisher
) {
  fun foo(id: Long) {
    val foo = fooRepository.getById(id)
    foo.invoke()
    foo.pollAll().forEach { eventPublisher.publish(it) }
  }
}
```
이후, 각 이벤트 리스너에서 Validator가 검증하고 실제 External Event Processor에 Event를 발행하면 명령이 이벤트로 전환된다.
주로, Kafka를 사용하게 되는데 Kafka에는 offset으로 이벤트가 발행 된 내역이 남으니 나중에 재현하기도 쉽다.



## 💡 3. 전부 읽고 난 후기
- 실제로 은행의 계정계 시스템에서 처리해야 될 내용들을 많이 볼 수 있었다. 해당 내용은 은행에서 기술 면접을 본다면 다뤄야 할 내용들이라고 생각한다.
- 분명히 많이 들어본 단어들이지만 뭔가 부족하게 부분이 많은 듯 하다. 이벤트 소싱에서 막히는 부분이 있어서 잘 읽히지 않았던 것 같다.
- 실제, 코드를 작성하면서 따라가니 이해를 하기가 한 층 더 편했다. 용어가 이해가 안 될 때에는 직접 코드를 써보는 습관이 좋은 것 같다.

## ❓ 4. 특별히 궁금했던 부분
- 보상 트랜잭션을 처리하는 경우에 단 건 필드 같은 경우는 보상 트랜잭션을 처리하기 위한 API를 작성하기가 용이합니다. 그러나, 실제로 PUT 업데이트를 하는 경우에는 업데이트 되기 이전에 상태 값으로 되돌아가야하는데 이런 경우에는 보상 트랜잭션을 어떻게 발행 할 수 있을까요?
  - 생성된 건 delete를 보내면 되지만, 업데이트의 경우는 client 입장에서 변경되기 이전에 client의 상태를 알고 다시 PUT 요청을 보내야 할텐데... 그럼 업데이트 요청을 하기 전에 해당 key 값에 대한 데이터를 알고 있어야 하니 조회를 필수적으로 해야겠네요..
  - 혹은, 업데이트 시 업데이트 이전의 데이터를 클라이언트에게 전달드려야 하는데 이건 통신 목적에 맞지 않는 것 같아요. 다른 방법이 떠오르는게 있나요?

