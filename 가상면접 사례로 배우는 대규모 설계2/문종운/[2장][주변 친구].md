# 📚 스터디 템플릿

## 📖 1. 목차를 읽기 전에 든 생각
- 아, 핀더 같은 앱을 만들 때 고려해야 할 점에 대해서 나오겠다!
- 주변 친구이니, 기본적으로 전 장에 있었던 위치 기반이 중요 할 것 같다.
- 다만, 전장에서는 위치가 고정되어 있었지만, 이건 주변 사람들의 위치가 지속적으로 변경되니 위치를 고정 할 필요는 있을 것 같다.
- 각 유저 별로 n분 마다 위치를 캐시에 보관하고 구글 S2를 사용하는게 좋겠다. (쿼드트리는 매번 갱신해야 하니 오히려 서비스에 지연을 발생시킬듯)

## 📝 2. 내용 정리
- 위치 정보를 갱신해주어야 한다는 점에서 WebSocket 방식을 택해야 한다. Http 방식은 Stateless 이기에 지속적인 연결 비용(TCP/IP)가 발생한다.
- 모든 유저의 데이터를 가지고 오는 경우에는 유저 ID를 바탕으로 샤딩을 구축하여 데이터 조회 성능을 충분히 개선 할 수 있다.
- 클라이언트 이벤트 추적을 위해 message에 전송되는 userId를 바탕으로 messageBus 를 찾고 전송한다. 이 때, 경량 메세지 버스인 레디스를 이용해도 된다. (카프카, RabbitMQ) 모두 괜찮겠지만 차이점이 있을듯하다.
- ws 서버는 stateful 이기에 제거 시에 주의해야 한다. -> ws 서버에 연결 된 모든 세션이 사라짐(단기간이지만 유저 위치 정보 못 가져옴) -> 노드 상태를 확인하는 방식을 도입(k8s의 istio와 유사)
- 대용량 데이터 처리 시에 CPU, I/O, 메모리 사용량을 적절하게 추산해야 한다. 추산 된 결과로 하여금 데이터 스토리지를 결정하고 확장해야 한다. (구글 엔지니어는 이렇게 일한다. 에서도 나오는 부분)

## 💡 3. 전부 읽고 난 후기
- 하나의 사용자 별로 영역을 지정하여 가지고 온다면 더 빨리 가지고 오지 않을까 하였지만, 연산 과정이 한 번 더 필요하므로 적절하지 않은 구조였다. (구글 S2), 단순히 고객 과의 거리, 비즈니스 적 사용자 간의 거리만으로도 충분히 필터링이 가능하다.
- Pub-Sub의 동작 원리 자체는 Observer 방식으로 이해하고 있으나, 상용화되어 널리 사용되고 있는 기술들에 대한 디테일이 부족한 것 같다. 특히, 아직까지도 적절한 메모리, 적절한 디스크 용량을 모르겠다. (상황에 따라 받아들일 수 있는 정도이겠지만)
- WS는 생각을 못했는데, 좋은 방식 인 것 같다. 특히, 게임 서버, 채팅 서버(Discord, zep) 같은 양방향 소통이 필요한 경우에는 ws를 먼저 고려해보는 것도 좋을 듯 하다.
- 읽을 때마다 너무 어렵다. 특히 QPS 추산 부분, 유저 당 메모리 사용량 추정등이 어렵다. -> 시간 복잡도만 따로 공부해야하나🥲

## ❓ 4. 특별히 궁금했던 부분
- 대용량 레디스 메모리 100GB * 2 는 상당히 거대한 크기라고 생각이 든다. (와닿지가 않음)
- 두 개의 레디스 서버를 두고 클러스터링 하여 여러 개의 replica를 구성한다고 하자. 때때로, cluster 서버가 죽는 경우가 있는데 이럴 경우는 어떻게 대체하지?
- 오버 프로비저닝이 뭘까
  - SSD 저장 공간의 특정 부분을 캐시로서 활용하는 것.   
- 설계의 변경에 있어서 위치 정보 동의를 한 사용자들에 한해 지오해시 방식으로 주변 위치를 알려준다. -> HotSpot 문제가 생길 수 있지 않을까? 지오해시는 결국 동일 격자로 나누어진다. 100만명 기준 10%, 위치 정보 데이터 100 Byte -> 10만 * 10만 * 100Byte = 1테라 // 계산을 잘못한건가..
- ws 연결 시 레디스의 메모리는 그렇다고 해도, ws로 연결되어 있는 WAS의 세션 메모리는 어떻게 감당하지? (port 65536이 꽉찰 가능성..., WAS 또한 분산이 필요해보임 -> 책을 다시 읽어보니 WS 서버 분산해두었음)
