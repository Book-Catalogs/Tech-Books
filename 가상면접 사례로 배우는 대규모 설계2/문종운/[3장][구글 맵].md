# 📚 스터디 템플릿

## 📖 1. 목차를 읽기 전에 든 생각
- 책이 빌드업을 하고 있다. 근접성 서비스, 주변 친구가 적절하게 결합이 되어야 한다.
- 위치를 보여주는 경우에는 가장 많이 사용되는 **쿼드 트리, 지오 해시를 사용**해야 할 것 이다.
- 각 위치 별 정보는 **쓰기보다는 읽기 요청이 더 많다.** 내 위치 정보가 아닌 부분에 대해서는 **변경이 자주 발생하지 않으므로 캐시를 사용**하는 것이 좋다.
- 서버 별 데이터의 정합성이 중요하지 않으므로 꼭 레디스를 사용하지 않고 **인 메모리 캐시**로도 충분 할 듯 하다. 레디스 비용 감축 혹은 서버 별 메모리 사용은 직접 비용 계산을 해봐야 알 수 있다.
- 클라이언트에게 정보를 내려다 줄 때에는 **내 위치와 지도가 얼마만큼 확대 되었느냐에 따라 보여줘야 할 개수**가 다를 것이다. (각 건물 정보마다 level을 지정해두면 된다.) `level < 2, level < 3 ...`
- 내 위치가 변할 때마다 다른 사람들에게 바로 즉각적으로 데이터를 보내 줄 필요는 없으므로 stateless로 충분하다. 단, 내 주변 친구 서비스가 필요하다면 WebSocket과 MessageBroker를 활용해야 한다.

## 📝 2. 내용 정리
- 사용자 위치 갱신, 경로 안내(ETA 포함), 지도 표시에 대한 내용을 다루고 있다.

### 지도 표시
모바일 클라이언트에서 지도 표시를 잘 보여주는 것도 중요하지만 빠른 속도로 지도를 보여주는 것도 중요하다.
먼저, 지구는 타원의 구 형태로 되어있기 때문에 타원의 구 형태를 평면으로 보여주는 것이 필요하다. 방법은 여러가지가 있는데 대표젹으로, Mercator, Gall Peters, Winkel triple 등이 있다. 구글의 경우에는 Mercator를 좀 더 발전시켜서 사용 중이다.
더 자세한 내용은 `https://medium.com/google-design/google-maps-cb0326d165f5`에서 알 수 있다.

지도를 표시 하는 경우에 사진 데이터를 보내줄 때 무한정으로 높은 픽셀의 데이터를 보내주기에는 유저의 QPS를 생각하면 캐시를 하더라도 감당 불가능한 수준의 데이터가 전송된다. 따라서, 각 위치를 격자로 나누고 그 격자 만큼의 데이터 만큼만 미리 찍어둔다면 성능을 개선 할 수 있다.
이 때, 사진을 전송하는 방식은 클라이언트가 사진의 Depth를 변경 할 때마다 전송하는 방식과 서버에서 미리 해당 Depth 만큼의 사진을 저장해두고 보내주는 방식이 있을 수 있다. (여기서는 지오 해시를 쓴다면 지오 해시 키 값별로 URL을 설정하면 cdn에서 빠르게 사진을 보내 줄 수 있다.)

전 세계의 이미지를 256 * 256 픽셀로 보여준다고 가정하고, 지오해시를 통해 격자로 분리했을 때 Depth Level을 늘릴 때마다 해당 Depth의 사진을 다시 찍어 256 * 256 픽셀로 보여준다면 충분히 신뢰 할 만한 데이터를 보여줄 수 있다. 특히, 래스터 방식의 이미지를 사용하면 확대 시에 이미지가 깨지는 현상이 있으므로, 벡터 방식의 이미지를 사용하는 것이 좋다.

### 타일 개수 계산
확대 수준에 따라, 즉 레벨 별로 타일이 1, 4, 16으로 늘어난다고 한다면 실제 필요한 데이터는 기본 데이터 사이즈 * 4 * N(확대 사이즈) 이다.


### 경로 안내
경로 탐색 알고리즘에는 다익스트라, A* 등이 있다.  
경로 탐색 알고리즘에서 성능을 결정하는 가장 중요한 요소는 그래프의 크기이다. 그래프의 각 노드들을 어떻게 구성하느냐에 따라서 성능이 결정된다. 
따라서, **그래프를 관리 기능 단위로 분할**하는 것이 중요하다.

그래프의 관리 포인트의 구체성 정도를 상, 중, 하로 분리하여 노드를 분리하며 크게 세 가지로 구분하고 있다. 하지만, 사이즈를 더 크게 본다면 더 추상화 된 한 단계를 추가해도 될 것이다.
1. **지방도(local loads)** : 가장 작은 사이즈의 타일로 각 지방 데이터를 사용하여 좀 더 디테일한 타일 범위로 경로를 탐색한다.
2. **큰 관할구(district)** : 지방도보다 더 규모가 있는 사이즈이다. 우리나라의 예시로는 인천시, 서울시 같은 규모이다.
3. **주(state)** : 더 큰 규모의 사이즈이다. 미국의 주를 생각하면 된다. 우리나라는 주가 없으므로 예시에서 벗어난다.

지방도로 최대한 작은 구조에서 모든 지방도의 그래프를 가져와서 경로를 안내해주려고 시도하더라도 많은 사이즈의 지방도 데이터가 필요하다.  
따라서, 지방도에서 데이터를 전달하는 경우에도 시작 지점의 위도, 경도에서 출발하여 다음 경로로 이동 할 필요가 있다면 다음 타일의 리스트 타일에서 값을 가져와 계산하는 방식이 메모리에 부하를 덜 줄 것이다. (Lazy Loading)  

## 사용자 위치 갱신
사용자 위치 정보는 여러 방면으로 사용 될 수 있다.
- 도로 데이터 및 경로 안내 타일 갱신
- 실시간 교통 상황 데이터

고객의 위치 데이터 하나로 여러 일을 한 번에 처리해야 한다. 이러한 구조는 메시지 큐 구조에서 적합하다.
- 하나의 이벤트를 발행하고, 해당 이벤트를 구독하고 있는 여러 서비스에서 각자 처리하면 되기 때문이다.

## 💡 3. 전부 읽고 난 후기
- 구글 맵 지도를 사용 했을 때 거리 계산은 생각해보지 않았는데 한국에서는 그렇게 넓은 범위의 거리를 포괄하고 있지 않지만, 해외의 큰 거리에서의 거리를 계산한다고 하면 어떤 방식으로 하게 되는지를 생각해 볼 수 있는 좋은 기회였던 것 같다.
- 실제로 적용 할 수 있는가에 대한 부분을 여러 부분 생각을 하게 되는 것 같다. 정말 대규모의 서비스를 생각한다면 고려해야하는 부분이 너무 많은 것 같다는 생각이 들기도 했다.
- 앞 선 빌드업이 아니었다면 해당 부분을 이해하기가 쉽지 않았을 것 같다. 또한, 대용량으로 쓰는 경우에 카산드라 (NO-SQL) 기반의 DB를 사용한다고 자주 나오는데 얕게 나마 왜 카산드라 DB를 사용하는지 다른 NO-SQL DB와의 차이점은 무엇인지 살펴 볼 수 있어서 좋았다 

## ❓ 4. 특별히 궁금했던 부분
### POP(Point Of Presence)
- 통신하는 엔티티 사이의 인공적인 경계 지점 또는 네트워크 인터페이스 지점을 의미한다. 즉, 각 네트워크가 연결되는 지점을 의미한다.

### 사고지점 탐색
- 기존에 출발지로부터 도착지까지의 레코드 데이터를 바탕으로 해당 부분에 속한 부분을 찾는 부분에서 맨 마지막 레코드에서 해당 부분을 포함한 데이터를 찾으면 된다고 하는데, 실제로는 N개만 보면 되지만 코드 내부적으로는 자연스럽게 M개가 되지 않은가? 라는 생각이 든다.
- DB 조회 시점에서는 N개, 서버에 들어와서 M개의 조회는 결국 필요하다. DB에서의 병목을 줄이는 방법을 제시해준 것일까?

### ETA
- Estimated Time of Arrival 예상 도착 시간을 알려주는 서비스를 의미한다.
