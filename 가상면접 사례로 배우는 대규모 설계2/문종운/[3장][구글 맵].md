# 📚 스터디 템플릿

## 📖 1. 목차를 읽기 전에 든 생각
- 책이 빌드업을 하고 있다. 근접성 서비스, 주변 친구가 적절하게 결합이 되어야 한다.
- 위치를 보여주는 경우에는 가장 많이 사용되는 **쿼드 트리, 지오 해시를 사용**해야 할 것 이다.
- 각 위치 별 정보는 **쓰기보다는 읽기 요청이 더 많다.** 내 위치 정보가 아닌 부분에 대해서는 **변경이 자주 발생하지 않으므로 캐시를 사용**하는 것이 좋다.
- 서버 별 데이터의 정합성이 중요하지 않으므로 꼭 레디스를 사용하지 않고 **인 메모리 캐시**로도 충분 할 듯 하다. 레디스 비용 감축 혹은 서버 별 메모리 사용은 직접 비용 계산을 해봐야 알 수 있다.
- 클라이언트에게 정보를 내려다 줄 때에는 **내 위치와 지도가 얼마만큼 확대 되었느냐에 따라 보여줘야 할 개수**가 다를 것이다. (각 건물 정보마다 level을 지정해두면 된다.) `level < 2, level < 3 ...`
- 내 위치가 변할 때마다 다른 사람들에게 바로 즉각적으로 데이터를 보내 줄 필요는 없으므로 stateless로 충분하다. 단, 내 주변 친구 서비스가 필요하다면 WebSocket과 MessageBroker를 활용해야 한다.

## 📝 2. 내용 정리
- 사용자 위치 갱신, 지도 안내, 지도 표시에 대한 내용을 다루고 있다.

### 지도 표시
모바일 클라이언트에서 지도 표시를 잘 보여주는 것도 중요하지만 빠른 속도로 지도를 보여주는 것도 중요하다.
먼저, 지구는 타원의 구 형태로 되어있기 때문에 타원의 구 형태를 평면으로 보여주는 것이 필요하다. 방법은 여러가지가 있는데 대표젹으로, Mercator, Gall Peters, Winkel triple 등이 있다. 구글의 경우에는 Mercator를 좀 더 발전시켜서 사용 중이다.
더 자세한 내용은 `https://medium.com/google-design/google-maps-cb0326d165f5`에서 알 수 있다.

지도를 표시 하는 경우에 사진 데이터를 보내줄 때 무한정으로 높은 픽셀의 데이터를 보내주기에는 유저의 QPS를 생각하면 캐시를 하더라도 감당 불가능한 수준의 데이터가 전송된다. 따라서, 각 위치를 격자로 나누고 그 격자 만큼의 데이터 만큼만 미리 찍어둔다면 성능을 개선 할 수 있다.
이 때, 사진을 전송하는 방식은 클라이언트가 사진의 Depth를 변경 할 때마다 전송하는 방식과 서버에서 미리 해당 Depth 만큼의 사진을 저장해두고 보내주는 방식이 있을 수 있다.

전 세계의 이미지를 256 * 256 픽셀로 보여준다고 가정하고, 지오해시를 통해 격자로 분리했을 때 Depth Level을 늘릴 때마다 해당 Depth의 사진을 다시 찍어 256 * 256 픽셀로 보여준다면 충분히 신뢰 할 만한 데이터를 보여줄 수 있다. 특히, 래스터 방식의 이미지를 사용하면 확대 시에 이미지가 깨지는 현상이 있으므로, 벡터 방식의 이미지를 사용하는 것이 좋다.

### 지도 안내
지도 안내에서 가장 중요한 부분은 고객에게 출발 지점부터 도착 지점까지의 거리를 정확하게 알려주는 것이 중요하다.

## 💡 3. 전부 읽고 난 후기
- 구글 맵 지도를 사용 했을 때 거리 계산은 생각해보지 않았는데 한국에서는 그렇게 넓은 범위의 거리를 포괄하고 있지 않지만, 해외의 큰 거리에서의 거리를 계산한다고 하면 어떤 방식으로 하게 되는지를 생각해 볼 수 있는 좋은 기회였던 것 같다.
- 실제로 적용 할 수 있는가에 대한 부분을 여러 부분 생각을 하게 되는 것 같다. 정말 대규모의 서비스를 생각한다면 고려해야하는 부분이 너무 많은 것 같다는 생각이 들기도 했다.

## ❓ 4. 특별히 궁금했던 부분
### POP(Point Of Presence)
- 통신하는 엔티티 사이의 인공적인 경계 지점 또는 네트워크 인터페이스 지점을 의미한다. 즉, 각 네트워크가 연결되는 지점을 의미한다.

### 사고지점 탐색
- 기존에 출발지로부터 도착지까지의 레코드 데이터를 바탕으로 해당 부분에 속한 부분을 찾는 부분에서 맨 마지막 레코드에서 해당 부분을 포함한 데이터를 찾으면 된다고 하는데, 실제로는 N개만 보면 되지만 코드 내부적으로는 자연스럽게 M개가 되지 않은가? 라는 생각이 든다.
- DB 조회 시점에서는 N개, 서버에 들어와서 M개의 조회는 결국 필요하다. DB에서의 병목을 줄이는 방법을 제시해준 것일까?
