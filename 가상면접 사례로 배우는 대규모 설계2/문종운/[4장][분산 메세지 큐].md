# 📚 스터디 템플릿

## 📖 1. 목차를 읽기 전에 든 생각
- 분산 환경에서의 메시지 큐를 어떻게 다룰지에 대해서 주로 기술을 할 것 같다.
- 메세지를 처리하는 방식에 있어서 BackPressure를 어떻게 취급하는 것일까? 평소에 궁금했지만 자세히 기술되어 있으면 좋을 것 같다.
- 분산 메세지 큐로써 사용 할 수 있는 여러가지 애플리케이션들이 존재하는데 그것들의 차이점에 대해서도 기술을 해줄까?

## 📝 2. 내용 정리

### 메시지 큐의 장점
- **결합도 완화**  
  시스템 간의 의존성을 줄이며 유연성을 제공.
- **확장성 개선**  
  스케일 아웃이 용이하며, 생산자와 소비자를 늘려 규모를 확장 가능.
- **가용성 향상**  
  단일 장애 지점을 방지(SPOF).  
- **성능 개선**  
  비동기 처리 방식으로 서로 대기하지 않음.

### 메시지 큐 종류
- **카프카**, RocketMQ, RabbitMQ, Pulsar, ActiveMQ, ZeroMQ 등

### 메시지 큐 vs 이벤트 스트리밍 플랫폼
- 전통적인 메시지 큐는 **메시지 보관** 문제를 중시하지 않으며, 메시지 순서를 보장하지 않을 수 있음.
- 이벤트 스트리밍 플랫폼은 지속적 데이터 흐름과 보관에 초점을 맞춤.

### 메시지 모델
1. **일대일 모델**  
   - 한 소비자만 메시지를 가져갈 수 있는 모델.
2. **발행-구독 모델**  
   - **토픽**으로 메시지를 구분하며 다수 소비자에게 메시지를 전송 가능.

### 토픽, 파티션, 브로커
- **토픽**: 발행-구독 모델을 사용하기 위한 메시지 그룹 
- **파티셔닝**: 데이터 부하를 분산 처리.
- **브로커**: 각 파티션 관리.

### 소비자 그룹
- 토픽의 메시지를 소비하는데 있어서 소비자 그룹에 각 소비자는 동일한 토픽의 파티션을 가지고 올 수 없도록 한다.
- 병렬성으로 취급하게 되면 메시지의 소비 순서를 보장 할 수 없는데, 이를 방지해주도록 도와준다.

### 회전식 디스크에 대한 사실과 오해
- 회전식 디스크는 데이터 접근 패턴이 무작위일 경우에만 느려진다.
- 순차적 접근 한다면 느리지 않다. 디스크가 데이터를 탐색하는 원리만 생각해도 그렇다.

### 푸시 모델 vs 풀 모델
#### 푸시 모델
- **장점**: 낮은 지연 속도.  
- **단점**: **백프레셔가 제대로 안된다.** 즉, 소비자가 메시지를 처리하는 속도가 생산자가 메시지를 만드는 속도보다 느릴 경우, **소비자에게 큰 부하가 걸릴 가능성**이 있다.

#### 풀 모델
- **장점**: 소비자가 처리 속도를 결정하며 배치 처리 적합.  
- **단점**: 폴링 문제 발생 가능(롱 폴링으로 대체 가능).

## 소비자 재조정(rebalancing)
어떤 소비자가 어떤 파티션을 책임지는지 다시 정하는 프로세스다.  
파티션의 담당자는 브로커이니 생산자-브로커-소비자 간의 통신을 통해 브로커가 다시 재조정을 진행한다.

### 상태 저장소
- 소비자-파티션 배치 관계와 마지막 오프셋 저장.

### 사본 동기화(Replica Sync)
- 동기화 GAP 기준에 따라 **ACK**를 설정:
  - **ACK=all**: 영속성 높음.  
  - **ACK=1**: 리더 저장 후 즉시 응답.  
  - **ACK=0**: 메시지 손실 감수, 가장 빠름.

### 메시지 전달 방식
1. **최대 한 번 (At Most Once)**
   - 메시지가 전달 과정에서 소실되더라도 다시 전달되는 일은 없다.
   - ACK=0의 방식을 사용하는 방식이다.
   - 소비자가 메시지를 읽고 처리하기 전에 오프셋을 갱신한다.
3. **최소 한 번 (At Least Once)**
   - 메시지가 한 번 이상 전달될 수 있으나 메시지 소실은 발생하지 않는 방식
   - ACK=1 or ACK=all 구성을 이용한다.
   - 소비자가 데이터를 성공적으로 처리한 뒤에만 오프셋을 갱신한다.
   - 메시지를 처리한 소비자가 offset을 갱신하지 못하면 중복처리 될 수 있다.
4. **정확히 한 번 (Exactly Once)**
   - 중복을 허용하지 않으며 정확하게 한 번만 보내는 방식이다.
   - 구현이 어렵다.

### 메시지 필터링
- 브로커에서 메시지를 필터링하여 소비자는 원하는 메시지만 받도록 하는 방식
- 일단 메시지를 받고 필요 없는 메시지를 버리는 방식 (해당 방식 사용 중)

## 💡 3. 전부 읽고 난 후기
- 분산 메시지 큐를 직접 설계하고 만들어내는 과정을 보면서 실제로 어떤 부분을 고려해야하는 지 어떻게 사용해야 하는지를 알 수 있었다.
- 잘 정의 된 프로토콜만 있다면 확장이나 사용 용도는 본인이 직접 정의 할 수 있다는 것을 새삼 느낀다. 관련 영상으로는 대규모 카프카 마이그레이션에서도 느꼈던 것 같다. 어떤 기술을 사용 할 때에는 늘 표준(인터페이스)를 보자.

## ❓ 4. 특별히 궁금했던 부분
1. **WAL이란 무엇인가?**  
   (Write-Ahead Logging 관련 개념 학습 필요)
2. **리더 선출 기준**  
   - 리더 선정 시 어떤 소비자가 기준이 되는가?  
   - 책에서는 가장 늦게 응답한 소비자가 리더가 되는 듯 보이는데, 다른 기준도 존재할까?
3. 기존의 전통 메시지 큐에서도 부가적인 기능을 통해서 이벤트 스트림즈처럼 제공해주고 있다. 그렇다면 선택 기준은 비용이 되어야 할까?
