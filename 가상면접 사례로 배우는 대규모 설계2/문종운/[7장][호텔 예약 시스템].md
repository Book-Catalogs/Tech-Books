# 📚 스터디 템플릿

## 📖 1. 목차를 읽기 전에 든 생각
- 각자의 비즈니스에 따라 정확도와 속도에 대한 트레이드 오프를 고려해야 하는 것처럼, 이번 장에서 가장 중요한 것은 예약 시스템이니 정합성이 가장 중요 할 것이다.
- 예약이라는 행위 자체가 현실 세계에서는 단방향 Queue로 구현이 되어 있다면, 가상 세계에서는 분산 Queue로 구현이 되어있다. 분산 Queue 중에 가장 우선순위가 높은 사람이 예약이 되어야 한다.
- 분산 환경 체제에서 어떻게 데이터의 정합성을 관리 할 것인가. 많은 인원을 받으며 소통하는 과정에서 이벤트 기반을 사용한다면 유실되는 이벤트 메시지에 대해서는 어떻게 처리 할 것인지에 대한 내용을 다루지 않을까 싶다.

## 📝 2. 내용 정리

### 기능적 요구사항
- 호텔 정보 페이지 표시
- 객실 정보 페이지 표시
- 객실 예약 지원
- 관리자 페이지 지원
- 초과 예약 지원
- 유동적인 객실 가격

### 비기능적 요구사항
- 높은 수준의 동시성 : 성수기, 대규모 이벤트에 발생하는 동시성을 처리 할 수 있어야 한다.
- 적절한 지연 시간 : 응답시간이 빠르면 좋지만, 예약 시스템에 있어서는 응답시간보다는 예약이 정확하게 처리되는 것이 중요하므로 몇 초 정도 걸리는 것은 괜찮다.

### 데이터 모델
- 쓰기의 QPS가 약 3 정도 발생을 하니 읽기 성능이 좋고 ACID를 보장하는 RDBMS를 사용한다.
- 향후 2년 간의 예약가능한 모든 객실을 등록해놓는 시스템이기에 데이터가 8000만개 정도가 적재가 된다. 하지만 단일 데이터베이스로는 SPOF가 발생할 가능성이 있으므로 hotel_id로 샤딩을 하거나 DB를 클러스터링 해야 한다.

### 개략적 설계안
- 아키텍처로 MSA를 사용한다.
- 공개 API 게이트웨이, 호텔 서비스, 요금 서비스, 예약 서비스, 결제 서비스로 분리한다.
- 공개 API 게이트웨이에서는 처리율 제한 및 외부 API 라우팅을 담당한다.

### 동시성 문제
- 클라이언트와 서버가 통신하는 사이에서 동시성 문제가 발생 할 수 있는 경우는 두 가지 이다.
1. 더블클릭 이슈
2. 두 클라이언트가 같은 API를 동시에 호출하는 경우

1번 케이스의 경우에는 client에서 button의 onClick 이벤트를 deactivate 시킴으로써 예방 할 수 있으나 고객이 개발자 도구를 통해서 비정상적인 호출을 한다면 그래도 발생하기에 안정적인 방법은 아니다.
결국에 서버에서 **멱등성** 을 판단하기 위한 key 값이 필요하고 이를 DB에서 ID_Sequence Table(Serializable)을 사용함으로써 방지하도록 할 수 있다.

2번 케이스의 경우에는 처리하기 위한 3가지 방법이 있다.
- 비관적 락
- 낙관적 락
- 데이터베이스 제약 조건

### 비관적 락
- 데이터베이스의 record에 대해서 읽기 잠금을 걸어서 다른 트랜잭션에서 접근하지 못하도록 하면 데이터의 원자성이 보장 될 수 있다.
- 구현이 쉽고, 모든 갱신 연산에 대해서 원자성을 보장하므로 데이터베이스의 경합이 심하다면 적절한 방식이다.
- 하지만, 작업 처리량이 많아지고 Latency가 길어질수록 해당 record의 대한 잠금을 가지고 있으므로 서로가 서로의 자원의 release를 기다리고 있는 deadlock이 발생 할 수 있으며, 확장성이 떨어진다.

### 낙관적 락
- version 방식과 timestamp 방식으로 진행이 가능하나, timestamp 방식은 nano초 차이로 데이터의 정합성이 틀릴 수 있으므로 version 방식이 더 용이하다.

```bash
if: this.version NOT db.version - 1
  false
else:
  true
```
- 데이터베이스의 자원에 락을 걸지 않아 자원에 대한 경합이 심하지 않으나 실제로 실패를 하게 되면 Retry를 진행하게 되는데 이 때, 클라이언트의 많은 유입으로 인해서 경합이 늘어나면 클라이언트에게 좋지 않은 경험을 줄 수 있다.
- 따라서, 낙관적 락은 데이터베이스의 경합이 많지 않은 경우에 적합하다.

### 데이터베이스 제약조건
- Constraint를 추가하여 비즈니스에 따른 제약조건을 DB에 이관한다.
- 낙관적 락과 마찬가지로 데이터에 따른 경합이 늘어난다면 실패하는 케이스가 늘어나므로 후 처리가 어려워 질 수 있다.

### 캐시 도입
- 읽기 연산이 많은 작업이므로 캐시를 도입하면 읽기의 성능을 DB에서 조회 할 때보다 더 좋은 경험을 줄 수 있다.
- 하지만, 캐시를 도입함에 따라 잔여 객실 수에 대한 데이터 정합성을 보장하기는 어려워 진다.
- 따라서, 캐시의 대한 갱신은 DB에 먼저 적재하고 캐시를 다시 갱신하는 시스템을 반영한다. 혹은 CDC(Change Data Capture)를 사용한다.

### MSA 환경에서의 분산 트랜잭션 처리

#### 2PC(2-phase commit)
- coordinator를 도입하여 분산 트랜잭션 처리를 위한 key를 제공받고, 각 트랜잭션 요청의 phase마다 commit이 가능한지 확인하고 application 수준에서 요청에 대한 commit을 coordinator가 처리한다.
- 분산되어 있는 트랜잭션을 하나의 단일 서버에서 별도로 처리하므로 트랜잭션을 하나의 단일 서버에서 중재하여 보장 할 수 있으나, prepare(commit 준비 단계)가 승인되었다가 coordinator 서버가 다운되면 원자성을 보장 할 수 없게 된다. (이 부분은 프로토콜에 포함되지 않는다.)
- 마치, Orchestration SAGA 방식과 비슷하다.

#### SAGA
- Orchestration SAGA, Choreography SAGA 두 가지가 있다.
- Orchestration SAGA는 2PC와 비슷하게 동작한다. 하나의 Orchestra 서버에서 트랜잭션 매니저를 수행하며 각 트랜잭션을 관리하는 방식이다.
- Choreography SAGA는 각 API에 대한 Event 수행 시 해당 Event의 실패 처리에 대한 보상 트랜잭션 API가 구현되어 실패 시 해당 이벤트를 발행하여 상위 트랜잭션에 대한 처리가 되지 않도록 한다.

## 💡 3. 전부 읽고 난 후기
- 공부를 하면서 가장 많이 접했던 부분이고, 많이 읽었던 부분과 실제로 어떻게 구현할지에 대해서도 예상과 크게 다르지는 않아서 편하게 읽었던 것 같다.
- 가장 공감갔던 부분은 MSA 설계에 대한 핵심은 ACID를 보장하기 위해서 더 복잡한 시스템을 추가로 설계해주어야 한다는 부분이 가장 많이 공감되었다.
- 이를 위해서 실제 애플리케이션 코드도 복잡해질 것이다.

```kotlin
class RollbackUtils {
  companion object {
    fun rollback(callback: () -> Unit): Unit {
      callback()
    }
  } 
}

try {
   ....
} catch (e: TimeoutException) {
  RollbackUtils.rollback(rollbackFunction)
}
```

## ❓ 4. 특별히 궁금했던 부분
- SPOF를 방지하기 위해서 우리는 계속해서 서버를 분리하고 있다. 어떤 단위로 분리하는게 좋은 것일까? 코드 작성은 갈수록 편해지고 있다. SPOF를 방지하고 더 쾌적한 서비스를 전달하는 것이 목적일까. 그래도 비즈니스를 확장하는데에서는 시간이 걸리니 추후에 분리하는 것이 좋을까?
- 애플리케이션 코드에 CDC capture 를 사용해서 도메인의 변경을 감지하는 로직이 있었다. 비슷한 개념일까?
- 실제로, 10%를 초과하여 예약을 가능하도록 하였다. 당일 날 취소 고객이 없어 해당 호텔에 숙박가능한 객실이 없다. 이런 경우를 비즈니스적으로 어떻게 해결하고 있는가?
