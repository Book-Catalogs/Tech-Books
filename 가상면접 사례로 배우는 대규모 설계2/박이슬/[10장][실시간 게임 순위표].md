# 📚 스터디 템플릿
## 📖 1. 목차를 읽기 전에 든 생각
- 레디스의 sorted set을 활용해서 구현할 수 있을 것 같다.
- 레디스 말고 또 어떤 방법으로 구현할 수 있을까?
- 동점자 계산은 어떻게 해야할까?

## 📝 2. 내용 정리
### 2단계
#### 데이터 모델
- 관계형 DB
  - 다량의 읽기 부하를 처리하기 어렵다.
  - 색인을 추가하고 LIMIT 절을 사용하여 최적화하여도 규모 확장성 문제와 순위표 상단에 있지 않은 사용자를 간단히 찾을 수 없는 문제가 있다.
- 레디스
  - 정렬 집합(sorted set) 제공
    - 해시 테이블과 스킵 리스트 자료구조 사용
      - 스킵 리스트란? 빠른 검색을 가능하게 하는 자료구조로, 정렬된 연결 리스트에 다단계 색인을 두는 구조
- 저장소 요구사항
  - 데이터 영속성을 위해 레디스는 데이터를 디스크에 영속적으로 보관하는 옵션을 지원한다.
  - 그러나 디스크에서 데이터를 읽어 인스턴스를 재시작하려면 시간이 많이 걸린다.
  - 그래서 보통 레디스에 읽기 사본을 두는 식으로 구성한다. 주 서버에 장애가 생기면 읽기 사본을 승격시켜 주 서버로 만들고, 새로운 읽기 사본을 만들어 연결한다.
 
### 3단계
#### 클라우드 서비스 사용 여부
- 자체 서비스 이용
- AWS 같은 클라우드 서비스 이용

#### 레디스 규모 확장
- 데이터 샤딩 방안
  - 고정 파티션: 순위표에 등장하는 범위에 따라 나눔
    - 사용자 ID와 점수 사이의 관계를 저장하는 2차 캐시를 통해 성능을 더 높일 수 있다.
    - 사용자의 점수가 높아져서 다른 샤드로 옮겨야 할 땐 해당 샤드에서 제거한 후 새 샤드로 옮겨야 한다.
  - 해시 파티션: 레디스 클러스터를 사용하며, 각각의 키가 특정한 해시 슬롯에 속하도록 하는 샤딩 기법이다.
    - 상위 10명을 검색하는 것이 까다롭다. 모든 샤드에서 상위 10명을 받아 애플리케이션 내에서 다시 정렬하는 분산-수집 접근법을 사용해야 한다.

### 4단계
#### 더 빠른 조회 및 동점자 순위 판정 방안
- 순위표에 표시할 사용자 ID와 사용자 객체 사이의 대응관계를 저장(캐시)
- 두 사용자의 점수가 같은 경우 누가 먼저 점수를 받았는지에 따라 순위를 매기기
  - 사용자 ID와 사용자가 마지막으로 승리한 경기의 타임 스탬프 사이의 대응관계를 저장하여 동점자 판정

#### 시스템 장애 복구
- 게임에서 이길 때마다 MySQL에 타임스탬프와 사실을 기록하면 간단히 복구 가능

## 💡 3. 전부 읽고 난 후기
- 이전에 프로젝트를 진행하면서 실시간 순위표를 구현한 적이 있었는데 그때도 레디스의 Sorted set을 사용했어서 그때의 기억을 떠올리며 읽었다.

## ❓ 4. 특별히 궁금했던 부분
