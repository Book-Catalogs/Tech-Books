# 📚 스터디 템플릿
## 📖 1. 목차를 읽기 전에 든 생각
- 결제 시스템이면 트랜잭션 보장이 너무너무 중요할 것 같다.

## 📝 2. 내용 정리
#### 원장 - p376
- 결제 트랜잭션에 대한 금융 기록

#### 지갑 - p376
- 판매자의 계정 잔액을 기록하거나 특정 사용자가 결제한 총 금액 기록

#### 일반적인 결제 흐름 - p376
1. 사용자가 주문하면 결제 이벤트가 생성되어 결제 서비스로 전공
2. 결제 서비스에서 결제 이벤트를 DB에 저장 (🧐 결제 이벤트 발행을 보장하기 위해서!?)
3. 결제 서비스는 결제 주문마다 결제 실행자 호출
4. 결제 실행자는 결제 주문을 DB에 저장
5. 결제 실행자가 외부 PSP를 호출하여 신용 카드 결제 처리
6. 결제 실행자가 결제를 성공적으로 처리하면 결제 서비스는 지갑을 갱신하여 특정 판매자 잔고 기록
7. 지갑 서버는 갱신된 잔고 정보를 DB에 저장
8. 지갑 서비스가 판매자 잔고를 성곡적으로 갱신하면 결제 서비스는 원장 호출
9. 원장 서비스는 새 원장 정보를 DB에 추가

#### 결제 서비스 API - p377
- 결제 이벤트 실행 API의 요청 매개변수 중 payment_order_id는 전역적으로 고유한 ID -> 멱등 키
  - 데이터 타입이 double이 아닌 string인 이유는 프로토콜, 소프트웨어, 하드웨어에 따라 직렬화/역직렬화에 사용하는 숫자 정밀도가 다를 수 있어서 (반올림 오류)
  - 이 숫자는 매우 클수도 작을 수도 있어서 (double로는 다 담지 못해서?)
 
#### 복식부기 원장 시스템 - p380
- 복식부기: 모든 결제 거래를 두 개의 별도 원장 계좌에 같은 금액으로 기록
  - 한 계좌에서는 차감, 다른 계좌에서는 입금
  - 모든 거래 항목의 합계는 0이어야 한다.
  - 결제 주기의 일관성 보장
 
#### 조정 - p386
- 관련 서비스 간의 상태를 주기적으로 비교하여 일치하는지 확인하는 것
- 조정 시스템은 매일 밤 조정 시스템과 모든 거래 내역 비교
- 결제 시스템의 내부 일관성을 확인할 때도 사용, 예를 들어 원장과 지갑의 상태가 같은지 확인

#### 내부 서비스 간 커뮤니케이션 - p388
- 동기식 통신은 설계하기는 쉽지만 서비스의 자율성을 높이기에는 적합하지 않다. 의존성 그래프가 커지면 전반적 성능은 낮아진다.
- 비동기 통신은 설계의 단순성과 데이터 일관성과 시스템 확장성 및 장애 감내 능력과 맞바꿨다.
- 비지니스 로직이 복잡하고 타사 서비스 의존성이 높은 대규모 결제 시스템에는 비동기 통신이 더 나은 선택

#### 결제 실패 처리 - p390
- 재시도 큐 및 실패 메시지 큐 사용
- [Reliable Processing in a Streaming Payment System](https://www.youtube.com/watch?v=5TD8m7w1xE0)
- [Enabling Seamless Kafka Async Queuing with Consumer Proxy](https://www.uber.com/en-KR/blog/kafka-async-queuing-with-consumer-proxy)

#### 정확히 한 번만 전달
- 최소 한 번 실행: 재시도
  - 지수적 백오프 사용, 지나치게 공격적인 재시도 전략은 컴퓨팅 자원을 낭비하고 서비스 과부하 유발
  - 에러 코드를 반환할 때 [Retry-After](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Retry-After) 헤더를 같이 붙여서 반환
- 최대 한 번 실행: 멱등성
  - 결제 요청 HTTP 헤더에 <멱등 키: 값> 형태로 멱등 키 추가
    - 스트라이프, 페이팔 같은 많은 기술 회사가 UUID를 멱등 키로 권장하며 사용
  - 시나리오 1: 고객이 결제 버튼을 빠르게 두 번 클릭하는 경우
    - DB의 고유 키 제약 조건을 활용 -> DB 테이블의 기본 키를 멱등키로 사용
  - 시나리오 2: PSP가 결제를 성공적으로 처리했지만 네트워크 오류로 응답이 결제 시스템에 전달되지 못하여, 사용자가 결제 버튼을 다시 클릭하는 경우
    - 결제 서비스는 PSP에 비중독 난수를 전송하고 PSP는 해당 난수에 대응되는 토큰 발행
    - 이 난수는 결제 주문을 유일하게 식별하는 구실, 토큰과 일대일로 대응, 토큰도 결재 주문을 유일하게 식별 가능
    - 사용자가 결제 버튼을 다시 눌러도 결제 주문이 같으니 PSP로 전송되는 토큰도 같아서 이중 결제로 판단
   
#### 일관성
- 내부 서비스 간 -> 정확히 한 번 처리
- 내부 서비스와 외부 서비스 간 -> 멱등성과 조정 프로세스 활용
- 데이터 다중화
  1. 주 DB에서만 읽기, 쓰기 연산 처리 -> 설정이 쉽지만 규모 확장성이 떨어짐
  2. 모든 사본 항상 동기화

## 💡 3. 전부 읽고 난 후기

## ❓ 4. 특별히 궁금했던 부분
