# 📚 스터디 템플릿
## 📖 1. 목차를 읽기 전에 든 생각
- 전자 지갑도 돈과 관련된 것이니 11장처럼 정확한 처리가 중요할 것이다.
- 전자 지갑 설계는 어떻게 해야할까 궁금하다!

## 📝 2. 내용 정리
### 분산 트랜잭션
분산 트랜잭션은 여러 노드의 프로세스를 원자적인 하나의 트랜잭션으로 묶는 방안

#### 2단계 커밋
1. 조정자는 정상적으로 여러 디비에 읽기 및 쓰기 작업을 수행하며, 그 결과로 해당 디비에는 락이 걸린다.
2. 애플리케이션이 트랜잭션을 커밋하려 할 때 조정자는 모든 디비에 트랜잭션 준비 요청
3. 조정자는 모든 디비의 응답을 받아 다음 절차 수행
   a. 모든 디비가 '예'라고 응답 -> 조정자는 모든 디비에 해당 트랜잭션 커밋 요청
   b. 어느 한 디비라고 '아니요'라고 응답 -> 조정자는 모든 디비에 트랜잭션 중단 요청
- 두 단계가 하나의 트랜잭션
- 준비 단계를 실행하려면 디비 트랜잭션 실행 방식 변경 필요 (저수준 방안)
- 다른 노드의 메시지를 기다리는 동안 락이 오랫동안 잠김 상태로 남을 수 있어서 성능이 좋지 않다.
- 조정자가 SPOF(Single-Point-Of-Failure)가 될 수 있다.

#### TC/C(Try-Confirm/Cancle)
1. 조정자는 모든 디비에 트랜잭션에 필요한 자원 예약 요청
2. 조정자는 모든 디비로부터 회신을 받는다.
   - 모두 '예'라고 응답 -> 조정자는 모든 디비에 작업 확인을 요청 (시도-확정 절차)
   - 어느 하나라도 '아니요'라고 응답 -> 조정자는 모든 디비에 작업 취소 요청 (취소-시도 절차)
- 각 단계가 별도 트랜잭션
- 실행 취소 절차를 비지니스 로직으로 구현 (고수준 방안)
- 특정 디비에 구애받지 않는다.
- 애플리케이션 계층의 비지니스 로직에서 세부 사항을 관리하고 분산 트랜잭션의 복잡성을 처리해야 한다.
- TC/C 실행 도중에 지갑 서비스가 다시 시작되면?
  - 과거 모든 작업 기록이 사라질 수 있으며, 어떻게 복구해야 할지 알 수 없게 될 수 있다.
  - TC/C의 진행 상황, 각 단계 상태 정보를 트랜잭션 디비에 저장하면 된다.

##### 2PC vs TC/C
| 단계               | 2PC                                           | TC/C                                             |
|------------------|----------------------------------------------|-------------------------------------------------|
| 첫 번째 단계       | 로컬 트랜잭션은 아직 완료되지 않은 상태                 | 모든 로컬 트랜잭션이 커밋되거나 취소된 상태로 종료           |
| 두 번째 단계: 성공  | 모든 로컬 트랜잭션을 커밋                          | 필요한 경우 새 로컬 트랜잭션 실행                         |
| 두 번째 단계: 실해  | 모든 로컬 트랜잭션 취소                          | 이미 커밋된 트랜잭션의 실행 결과 되돌림(undo)                |
 
#### 사가
1. 모든 연산은 순서대로 정렬. 각 연산은 자기 디비에 독립 트랜잭션으로 실행
2. 연산은 첫 번 째부터 마지막 순서대로 실행. 한 연산이 완료되면 다음 연산 개시
3. 연산이 실패하면 전체 프로세스는 실패한 연산부터 맨 처음 연산까지 역순으로 보상 트랜잭션을 통해 롤백. 따라서 n개의 연산을 실행하는 분산 트랜잭션은 보상 트랜잭션까지 총 2n개의 연산을 준비해야 함
- 연산 실행 순서 조율
  - 분산 조율: MSA에서 사가 분산 트랜잭션에 관련된 모든 서비스가 다른 서비스의 이벤트를 구독하여 작업을 수행하는 방식 (탈 중앙화된 조율 방식)
  - 중앙 집중형 조율: 하나의 조정자가 모든 서비스가 올바른 순서로 작업이 실행하도록 조율

##### TC/C vs 사가
| 특징                             | TC/C                           | 사가                                |
|--------------------------------|------------------------------|-----------------------------------|
| 보상 트랜잭션 실행                | 취소 단계에서                     | 롤백 단계에서                         |
| 중앙 조정                        | 예                            | 예 (중앙 집중형 조율 모드에서만)            |
| 작업 실행 순서                   | 임의                           | 선형                                |
| 병렬 실행 가능성                  | 예                            | 아니요 (선형적 실행)                     |
| 일시적으로 일관되지 않은 상태 허용 | 예                            | 예                                 |
| 구현 계층: 애플리케이션 또는 디비  | 애플리케이션                     | 애플리케이션                          |
- 지연 시간 요구사항이 없거나 서비스 수가 매우 적다면 아무거나
- 지연 시간에 민감하고 많은 서비스/운영이 관계된 시스템이라면 TC/C

### 이벤트 소싱
- 문제의 근본 원인을 역추적하고 모든 계정에서 발생하는 연산을 감사할 방법 -> 이벤트 소싱
- 용어 정리
  - 명령: 외부에서 전달된, 의도가 명확한 요청, 일반적으로 FIFO 큐에 저장
    - 명령은 의도가 명확하지만 사실은 아니기 때문에 유효하지 않을 수 있다. 따라서 작업 이행 전에 반드시 명령의 유효성을 검사해야 한다.
    - 검사를 통과한 명령은 반드시 이행되어야 한다.
  - 이벤트: 명령 이행 결과, 이벤트 순서는 명령 순서를 따르므로 FIFO 큐에 저장
    - 이벤트는 검증된 사실로, 실행이 끝난 상태
    - 명령에는 무작위성이나 I/O가 포함될 수 있지만 이벤트는 결정론적이다.
  - 상태: 이벤트가 적용될 때 변경되는 내용
  - 상태 기계: 이벤트 소싱 프로세스 구동
    1. 명령의 유효성을 검사하고 이벤트 생성
    2. 이벤트를 적용하여 상태 갱신
   
#### 재현성
- 이벤트 리스트는 불변이고(과거에 발생한 이벤트의 이력을 변경할 수 없다) 상태 기계 로직은 결정론적이므로 이벤트 이력을 재생하여 만들어낸 상태는 언제나 동일

#### CQRS(명령-질의 책임 분리)
- 이벤트 소싱에서 모든 이벤트를 외부에 보내어 이벤트를 수신하는 외부 주체가 직접 상태를 재구축할 수 있다.
- 상태 기록을 담당하는 상태 기계는 하나고, 읽기 전용 상태 기계는 여러 개 있을 수 있다.
  - 읽기 전용 상태 기계는 상태 뷰를 만들고, 이 뷰는 질의에 이용된다.
- 결과적 일관성 모델을 따른다.
  
## 💡 3. 전부 읽고 난 후기
- 분산 트랜잭션, 이벤트 소싱 너무 어렵다...^^

## ❓ 4. 특별히 궁금했던 부분
- p405 왜 TPS를 거론한다는 것은 트랜잭션 기반 데이터베이스를 사용한다는 뜻인지?
- p406 API 설계의 요청 인자를 보면 멱등성을 위해 trancsaction_id를 넘기는데, trancsaction_id가 잘못 요청될 경우는 어떻게 처리하면 좋을까?
- p410 '애플리케이션이 트랜잭션을 커밋하려 할 때 조정자는 모든 데이터베이스에 트랜잭션 준비를 요청한다.' 애플리케이션 단의 트랜잭션과 DB의 트랜잭션은 분리되어 있는건가?
- p415 TC/C 실행 도중에 지갑 서비스가 다시 시작되면 왜 과거 모든 작업 기록이 사라질 수 있는지?
- p417 유효한 연산 순서 이해가 안가요 ㅠㅠ
