## 📖 1. 목차를 읽기 전에 든 생각
- Kafka vs RabbitMQ
- Redis, Kafka, RabbitMQ 외 분산 메시지 큐가 어떤게 있을까?
- 분산 메시지 큐를 사용할 때 주의할 점은 뭐가 있을까?

## 📝 2. 내용 정리
### 분산 메시지 큐 장점
1. 결합도 완화: 컴포넌트 각각 독립적 갱신 가능
2. 규모 확장성 개선: 트래픽 부하에 맞게 생산자, 소비자 각각 규모 향상 가능
3. 가용성 개선: 특정 컴포넌트에 장애가 발생해도 다른 컴포넌트는 큐와 계속 상호작용 가능
4. 성능 개선: 비동기 통신 가능

### 이벤트 스트리밍 플랫폼이 전통적 메시지 큐와 다른 점
 데이터 장기 보관, 메시지 반복 소비. 소비 순서 보장

### 메시지 모델
1. 일대일 모델: 큐에 전송된 메시지는 한 소비자만 가져갈 수 있다. 어떤 소비자가 메시지를 가져가면 메시지는 큐에서 삭제된다.
2. 발행-구독 모델: 토픽을 구독하는 모든 소비자에게 메시지를 전달한다.

### 데이터 저장소
- 선택지 1: 데이터베이스
  - 데이터 저장 요구사항을 맞출 수는 있지만 읽기/쓰기 연산이 동시에 대규모로 발생하는 사용 패턴을 지원하기 어렵다. 오히려 시스템 병목이 될 수 있다.
- 선택지 2: 쓰기 우선 로그(Write-Ahead-Log)
  - 새로운 항목이 추가되기만 하는 일반 파일
  - WAL에 대한 접근 패턴은 읽기/쓰기 전부 순차적이다.
  - 새 메시지는 활성 상태의 세그먼트 파일에만 추가된다.
 
### 메시지 자료 구조
- 메시지 키
  - 파티션을 정할 때 사용
  - 키가 주어지지 않은 메시지의 파티션은 무작위로 결정
  - 생상자는 파티션 선정 메커니즘을 직접 정의 가능
- 메시지 값: 페이로드, 일반 텍스트일 수도 있고 압축된 이진 블록일 수도 있다.

### 일괄 처리
- 한 번의 네트워크 요청으로 전송할 수 있도록 하기 때문에 값비싼 네트워크 왕복 비용 제거
- 더 큰 규모의 순차 쓰기 연산이 발생, 디스크 캐시에서 더 큰 규모의 연속된 공간 점유 -> 더 높은 디스크 접근 대역폭 달성
- 생산자 측
  - 생산자가 특정 파티션에 메시지를 보내기 위해 라우팅 계층을 도입한다. 라우팅 계층은 적절한 브로커에 메시지를 보내는 역할을 담당한다.
  - 라우팅 계층을 생산자 내부로 편입시키고 버퍼를 도입한다.
    - 네트워크를 거칠 필요가 줄여 전송 지연도 줄어든다.
    - 생산자는 메시지를 어느 파티션에 보낼지 결정하는 자신만의 로직을 가질 수 있다.
    - 전송할 메시지를 버퍼 메모리에 보관했다가 목적지로 일괄 전송하여 대역폭을 높일 수 있다.
- 소비자 측
  - 특정 파티션의 오프셋을 주고 해당 위치에서부터 이벤트를 묶어 가져온다.
 
### 푸시 vs 풀
- 푸시 모델: 브로커가 데이터를 소비자에게 보낸다.
- 풀 모델: 소비자가 브로커에서 데이터를 가져간다.
  1. 소비자 그룹-1에 합류하고 토픽-A 구독 (소비자 -> 그룹-1 전담 코디네이터(브로커1))
  2. 파티션-2 할당 (그룹-1 전담 코디네이터 -> 소비자)
  3. 메시지 수신 (토픽-A 파티션-2(브로커2) -> 소비자)
  4. 데이터 처리 및 오프셋 갱신 (소비자 -> 토픽-A 파티션-2(브로커2))
- 대부분의 메시지 큐는 풀 모델 지원

### 소비자 재조정
- 어떤 소비자가 어떤 파티션을 책임지는지 다시 정하는 프로세스
- 코디네이터: 소비자 재조정을 위해 소비자들과 통신하는 브로커 노드, 소비자로부터 오는 heartbeat를 살피고 각 소비자의 파티션 내 오프셋 정보 관리

### 상태 저장소
- 소비자에 대한 파티션의 배치 관계, 각 소비자 그룹이 각 파티션에서 마지막으로 가져간 메시지의 오프셋 정보가 저장된다.

### 메타데이터 저장소
- 토픽 설정이나 속성 정보 보관 (파티션 수, 메시지 보관 기간, 사본 배치 정보 등)
- 자주 변경되지 않으며 양도 적지만 높은 일관성을 요구하므로 주키퍼가 적절하다.

### 주키퍼
- 계층적 키-값 저장소
- 메타데이터와 상태 저장소는 주키퍼를 이용해 구현한다. 브로커는 이제 메시지 데이터 저장소만 유지
- 브로커 클러스터의 리더 선출 과정을 돕는다.

### 복제
- 각 파티션은 사본을 갖고, 사본들은 서로 다른 브로커 노드에 분산
- 사본 분산 계획: 사본을 파티션에 어떻게 분산할지 기술하는 것
- 사본 분산 계획은 리더 브로커 노드가 만들고 메타데이터 저장소에 보관

### 사본 동기화
- 어떤 한 노드의 장애로 메시지가 소실되는 것을 막기 위해 메시지는 여러 파티션에 두며, 각 파티션은 다시 여러 사본으로 복제한다.
- 동기화된 사본(In-Sync Replicas, ISR)은 리더와 동기화된 사본, 리더는 항상 ISR 상태

### 규모 확장성
- 생산자: 새로운 생산자 추가/삭제
- 소비자: 소비자 그룹 추가/삭제, 소비자 그룹 내 소비자는 재조정 메커니즘이 맡아 처리
- 브로커: 시스템에 설정된 사본 수보다 많은 사본 허용하여 기존 브로커 상태를 따라잡고 더 이상 필요 없는 노드 제거
- 파티션: 토픽의 규모를 늘리거나, 대역폭을 조정할 때 파티션 수 조정
  - 삭제 시 생산자는 메시지를 남은 두 파티션으로만 보내지만 소비자는 세 파티션 모두에서 메시지를 읽는다. 실제 파티션이 제거되는 시점에 생산자 그룹은 재조정 작업 개시

## 💡 3. 전부 읽고 난 후기
- 내용이 어려워서 완벽하게 이해한 느낌은 아니다.
- 카프카와 비슷한 부분이 많은 것 같아서 카프카를 제대로 공부해보고 싶다는 생각이 들었다.

## ❓ 4. 특별히 궁금했던 부분
- 잠까 나왔던 etcd는 무엇인가?
- 카프카에서 주키퍼가 사라졌다고 하는데 어떻게 변한 것인가?
