# 📚 스터디 템플릿
## 📖 1. 목차를 읽기 전에 든 생각
- 여기어때와 비슷한 시스템인가?
- 동시에 방을 예약하고 있을 떄 동시성 처리를 해줘야겠지?
- 한국에서 미국의 호텔을 예약할 때, 한국에서의 날짜와 미국에서의 날짜가 다를 때는 어떻게 처리해야할까?

## 📝 2. 내용 정리
### 2단계: 개략적 설계안 제시 및 동의 구하기
#### API 설계
- 예약 관련 API에서 신규 예약 접수의 전달 인자 중 reservationID는 이중 예약을 장지하고 동일한 예약은 한 번만 이루어지도록 보증하는 멱등 키이다.

#### 데이터 모델
- 데이터 접근 패턴: 읽기 > 쓰기
- 관계형 DB 선택
  - 관계형 DB는 읽기 빈도가 쓰기 연산에 비해 높은 작업 흐름을 잘 지원 <-> NoSQL은 대체로 쓰기 연산에 최적화
  - 관계형 DB는 ACID 속성(원자성, 일관성, 격리성, 영속성)을 보장
  - 관계형 DB를 사용하면 데이터를 쉽게 모델링하고 엔티티 간의 관계를 안정적으로 지원
- p237 스키마 디자인에는 큰 문제가 있다.
  - room_id는 에어비앤비 같은 회사에 적합하며, 호텔의 경우에는 특정 호텔의 특정 객실 유형을 예약하므로 적합하지 않다.
  - 호텔 객실 번호는 예약할 때가 아닌, 체크인 하는 시점에 부여된다.
  - 따라서 데이터 모델을 수정할 필요가 있다.
 
#### 개략적 설계안
- MSA 아키텍처 사용

### 3단계: 상세 설계
#### 개선된 데이터 모델
- 호텔 객실을 예약할 때는 특정 객실이 아닌 특정 객실 유형을 예약 -> API와 스키마 변경 필요
- 예약 API 경우
  - roomID를 roomTypeID로 변경
- 스키마의 경우
  - room_type_inventory 테이블 추가
    - 호텔의 모든 객실 유형을 담는 테이블로 예약 시스템에서 아주 중요
  - reservation 테이블에 room_id -> room_type_id로 변경
- 예약 데이터가 단일 DB에 담기에 너무 크다면
  - 현재 및 향후 예약 데이터만 저장한다. 예약 이력은 자주 접근하지 않으므 냉동 저장소로 옮길 수 있다.
  - DB를 hotel_id로 샤딩한다.

#### 동시성 문제
1. 첫 번째 시나리오: 같은 사용자가 예약 버튼을 여러 번 누를 수 있다.
- 클라이언트 측 구현
  - 클라이언트가 요청을 전송하고 난 다음 예약 버튼을 회색으로 표시하거나, 숨기거나, 비활성
  - 자바스크립트를 비활성하면 클라이언트 측 확인 절차는 우회할 수 있으므로 안정적인 방법은 아니다.
- 멱등 API 구현
  - 예약 API 요청에 멱등 키 추가

2. 두 번째 시나리오: 여러 사용자가 잔여 객실이 하나밖에 없는 유형의 객실을 동시에 예약한다.
- DB 트랜잭션 격리 수준이 serializable 이 아닌 경우
- 문제를 해결하기 위해 락을 활용해야 한다.
  - 비관적 락
  - 낙관적 락 -> 예약 QPS가 높지 않기 때문에 적합한 선택지
  - DB 제약 조건(constraint)

#### 시스템 규모 확장
- QPS가 늘어날 경우 시스템의 모든 서비스는 무상태 서비스이므로 서버를 추가하면 성능 문제는 해결할 수 있지만, DB는 단순히 서버를 늘리는 것만으로는 성능 문제를 해결할 수 없다.
- DB의 규모를 늘리는 방법은 샤딩을 적용하는 것이다.
  - 데이터를 어떻게 분배해야할까?
    - 이 시스템 대부분 질의는 hotel_id를 필터링 조건으로 사용하므로 hotel_id를 샤딩 조건으로 쓰면 좋다.
- 호텔 잔여 객실 데이터에는 캐시를 적용한다.
  - 호텔 잔여 객실 데이터는 현재와 미래의 데이터만이 중요하다.
  - TTL을 설정할 수 있는 레디스를 사용하면 적합하다. 레디스는 TTL과 LRU 캐시 교체 정책을 사용하여 메모리를 최적으로 활용할 수 있다.
  - 캐시 계층을 추가하면 DB와 캐시 사이 데이터 일관성 유지에 관한 새로운 도전에 직면한다.

#### 서비스 간 데이터 일관성
- MSA 아키텍처에서 데이터 일관성 문제를 해결하기 위해 사용되는 방법
  - 2단계 커밋(2-phase commit, 2PC): 여러 노드에 걸친 원자적 트랜잭션 실행을 보증하는 DB 프로토콜
    - 비중단 실행이 가능한 프로토콜이 아니므로 어느 한 노드에 장애가 발생하면 해당 장애가 복구될 때까지 진행 중단
  - 사가(Saga): 각 노드에 국지적으로 발생하는 트랜잭션을 하나로 엮은 것
    - 각각의 트랜잭션이 완료되면 다음 트랜잭션을 시작하는 트리커로 쓰일 메시지를 보낸다.
    - 어느 한 트랜잭션이라도 실패하면 사가는 그 이전 트랜잭션의 결과를 전부 되돌리는 트랜잭션들을 순차적으로 실행
    - 결과적 일관성에 의존

## 💡 3. 전부 읽고 난 후기
- 지금까지 읽은 챕터 중에 가장 이해가 잘 되는 챕터였다.

## ❓ 4. 특별히 궁금했던 부분
- 대규모 이벤트 처리를 해야할 때 다들 어떻게 구현할 것인가?
- 회원, 비회원에 대한 처리는 어떻게 하는 게 좋을까?
- p235 MSA 구조에서 객실과 호텔과 같이 API 설계할 때도 종속되는 관계인 경우는 같은 서버에 두고 처리하나요? (MSA 유경험자분들 어떻게 하나요!!)
- p237 room_type_rate 는 특정 객실 유형의 특정 일자 요금 정보를 담는 테이블인데, 왜 room_type_id를 안갖고 있는지...?
