# 📚 스터디 템플릿
## 📖 1. 목차를 읽기 전에 든 생각
- 이메일 서비스는 분산 메시지 큐를 쓰겠지?
- '분산'이 붙은 것 보니 빠른 처리를 위해 글로벌 곳곳에 이메일 서비스를 두나?
- 읽음/안읽음 처리, 스팸 처리 등을 처리하려면 생각보다 복잡할 수도

## 📝 2. 내용 정리
### 1단계 - 개략적인 규모 추정 p267
- 이메일 서비스는 많은 데이터를 처리해야 한다. -> 분산 데이터 베이스 솔루션 필요
  - 🤔 데이터를 한 곳에 너무 많이 보관되어 있으면 읽기 연산이 느려서?

### 2단계
#### 이메일 101
- 이메일 프로토콜
  - SMTP: 아매일을 다른 서버로 보내는 프로토콜
  - POP: 이메일을 수신하고 다운로드 하기 위한 프로토콜
    - 다운로드된 이메일은 서버에서 삭제됨 -> 한 서버에서만 읽을 수 있음
    - 이메일 일부만 읽을 수 없음
  - IMAP: 이메일을 수신하고 다운로드 하기 위한 프로토콜
    - POP과 달리 클릭하지 않으면 메시지는 다운로드 되지 않으며, 메일 서버에서 지워지지 않음 -> 여러 단말에서 읽을 수 있음
    - 이메일 열기 전 헤더만 다운로드
  - HTTPS
- DNS: 수신자 도메인의 메일 교환기 레코드 검색에 이용

#### 전통적 메일 서버
- 메일 전송 흐름 
  1. 앨리스는 아웃룩 클라이언트에 로그인 후, 이메일 작성 후 전송 -> 아웃룩 SMTP 서버로 전송
  2. 아웃룩 SMTP 서버 (<-> DNS 질의) -> 지메일 SMTP 서버
     - 😲 수신사 서버는 바로 IMAP/POP이 받는 게 아니라 SMTP 서버가 받는군?!
  4. 지메일 서버는 이메일을 저장하고 수신사가 읽어갈 수 있도록 함
  5. 수신자가 지메일에 로그인하면 지메일 클라이언트는 IMAP/POP 서버를 통해 새 이메일을 가져옴
- 저장소
  - 이메일을 파일 시스템의 디렉터리에 저장
  - 사용자별로 고유한 이름을 가진 디렉터리에 데이터 보관
  - 이메일 양이 많아지고 파일 구조가 복잡해지면 디스크 I/O 병목
  - 파일 시스템이므로 디스크 손상이나 서버 장애가 발생하면 가용성과 안정성이 떨어짐
  - 따라서 분산 데이터 저장소 계층이 필요해짐

#### 분산 메일 서버
- 분산 메일 서버 아키텍처
  - 웹서버: 사용자가 이용하는 요청/응답 서비스로 모든 이메일 API 요청은 전부 웹서버를 통함
  - 실시간 서버: 새로운 이메일 내역을 클라이언트에 실시간으로 전달하는 역할(상태 유지 서버)
    - 롱폴링이나 웹소켓으로 실시간 통신 지원
  - 메타데이터 DB: 이메일 메타데이터 저장
  - 첨부 파일 저장소: 아마존 S3 같은 객체 저장소 사용
  - 분산 캐시: 최근에 수신된 이메일은 자주 읽을 가능성이 높음, 레디스 활용
  - 검색 저장소: 분산 문서 저장소로 고속 텍스트 검색을 지원하는 역 인덱스 자료 구조 사용
 
#### 이메일 전송 절차
- p275
- 웹 서버에서 외부 전송 담당 SMTP 프로세스를 분리하므로써 전송용 SMTP 프로세스 규모를 독립적으로 조정 가능
- 외부 전송 큐 크기를 모니터링할 때 메일이 큐에 오래 남아있다면
  - 수신자 측 메일 서버에 장애 발생 -> 재전송, 백오프 전략
  - 이메일을 보낼 큐의 소비자 수가 불충분 -> 소비자 추가

#### 이메일 수신 절차
- p278
- 수신 이메일 큐는 메일 처리 작업 프로세스와 SMTP 서버 간의 결합도를 낮춰준다.

### 3단계
#### 메타데이터 DB
- 이메일 메타데이터 특성을 분석했을 때 관계형 DB, 분산 객체 저장소, NoSQL DB 모두 완벽히 지원하는 DB는 없다.
- 다음 조건을 충족해야 한다.
  - 어떤 단일 컬럼의 크기는 한 자릿수 MB 정도일 수 있다.
  - 강력한 데이터 일관성이 보장되어야 한다.
  - 디스크 I/O가 최소화되도록 설계되어야 한다.
  - 가용성이 아주 높아야 하고 일부 장애를 감내할 수 있어야 한다.
  - 증분 백업이 쉬워야 한다.
    - 🤔 증분 백업이란?
    - 증분 백업(Incremental backup)은 연속되는 데이터 사본들에 이전의 백업 복사본이 만들어진 이래로 변경된 부분만을 담은 것이다. 전체 복구가 필요하면 복원 프로세스는 마지막 풀 백업 + 복원 시점까지의 모든 증분 백업이 필요하다.
- user_id를 파티션 키로 사용하여 데이터 저장
- 읽은, 또는 읽지 않은 모든 메일을 질의하는 경우
  - where 조건에 is_read = true, is_read = false 로 질의하면 된다.
  - 하지만 데이터 모델은 NoSQL DB로 보통 파티션 키와 클러스터 키에 대한 질의만 허용한다.
  - 해결 방법은 애플리케이션 단에서 필터링을 수행하는 것이지만 대규모 서비스에서는 적합하지 않다.
  - 다른 방법은 테이블을 비정규화하여 해결하는 것이 보통이다. 읽은 상태과 읽지 않은 상태의 테이블 2개로 분할한다.

#### 검색
- 방안 1: 엘라스틱서치
- 방안 2: 맞춤형 검색 솔루션
  - 🤔 LSM(Log-Structured Merge)란?
  - https://jaeyeong951.medium.com/%EC%83%89%EC%9D%B8-index-%EC%9D%98-%EB%91%90-%EA%B0%80%EC%A7%80-%ED%98%95%ED%83%9C-lsm-%ED%8A%B8%EB%A6%AC-b-%ED%8A%B8%EB%A6%AC-7a4ab7887db5
  - LSM 트리가 쓰기에서 더 빠른 반면 B 트리는 읽기에서 더 빠르다.

#### 규모 확장성 및 가용성
- 가용성을 향상시키기 위해서 데이터를 여러 데이터센터에 다중화 필요

## 💡 3. 전부 읽고 난 후기
- 읽음/안읽음 메일을 질의하기 위해 NoSQL DB을 비정규화 하는 것이 신선했다.
- 이메일 서비스는 보통 이렇구나~ 하고 스무스하게 읽은 것 같다.
- LSM이라는 새로운 개념을 접하게 되어서 좋다.

## ❓ 4. 특별히 궁금했던 부분
- 대량의 데이터가 존재할 때 읽기 연산이 많은 서비스에서, 파티셔닝이나 샤딩을 하는 것이 좋을까? 아니면 인덱스를 많이 거는 것이 좋을까?
- p288 '검색 기능에서는 쓰기 연산이 읽기 연산보다 훨씬 많이 발생한다.' 이해가 안가요...
