# 📚 스터디 템플릿

## 📖 1. 목차를 읽기 전에 든 생각
예전에 순위 했을 때 redis썼는데 그 얘기를 하려나?

## 📝 2. 내용 정리
### 1단계
- 상위 10명의 플레이어를 표시한다.
- 특정 사용자의 순위를 표시한다.
- 어떤 사용자보다 4순위 위와 아래에 있는 사용자를 표시한다.
- 실시간으로 순위표에 반영한다.
- 확장성 가용성을 챙겨야 한다.

### 2단계

#### API 설계
- 게임 순위표 갱신 요청
- 순위표 조회
- 특정 사용자 순위 가져오기

#### 설계
- 승리 -> 점수 갱신 -> 순위표 서비스에서 점수 갱신 (저장소 저장) -> 필요할 때 조회해줌
- 서비스는 서버측에서 제공한다. (공격 방지)
- 카프카를 통해서 순위표 분석 푸시 알림등 다양한 서비스를 제공할 수 있음

#### 데이터 모델
- RDB : 규모 확장성이 크지 않다면 사용. insert, update, rank함수 등으로 사용하면 됨
  - 레코드가 수백만개로 늘어나면 불편, index, limit등으로만 제한해서 사용 가능
- redis : 정렬 집합
  - 정렬 집합의 각 원소는 점수와 연결됨. 내부적으로 해시테이블과 스킵 리스트를 사용(각각 저장과 정렬을 담당)
  - 스킵 리스트 : 연결 리스트에 다단계 색인을 둔다.
    - 중간 지점에 노드를 하나씩 더 건너뛰는 1차 2차 index를 두는것. 1234. 1 - 4, 1- 11
    - log(N)의 성능을 보인다.
- 2500만명이 사용해도 서버 한대로 처리가 가능하다.
- 데이터의 영속성은 고려해야함. 데이터를 디스크에 보관하는 방법을 제공하고 있음 + replicatioin을 둔다.

### 3단계
#### 클라우드 서비스
- 클라우드 서비스를 사용하지 않으면, 사용자 세부 정보는 mysql에 저장한다. 만약 이 작업이 오래걸리면 사용자 프로필을 캐시에 저장한다.
- 혹은, API 게이트웨이, 람다를 활용한다. 람다를 통해서 스토리지 계층의 명령을 호출해 얻은 결과를 게이터웨이에 전달하는 방식
- 서버 규모에 맞게 자동 확장이 가능해서 유리함

#### 규모 확장 - 샤딩
1. 고정 파티션
- 점수의 범위에 따라 파티션을 나눈다. (고르게 분포해야만 유리할 것)
- 상위 10명을 조회하면 특정 구간의 파티션에서만 뒤지기 때문에 결과가 좋을 것
2. 해시 파티션
- 레디스 클러스터를 사용한다. 각 키가 특정 해시 슬롯에 속하도록 한다.
- 상위 10명을 검색하려면 분산 수집을 해서 결과를 ㅁ로아야 한다는 복잡함이 존재한다.
3. 레디스 크기 조정
 - 쓰기작업이 많으면 그만큼 많은 메모리가 필요함. redis 밴치마킹을 사용해서 테스트 해보는 것도 방법

#### NoSQL
- dynamodb, 카산드라 mongoDB등이 있음
- 파티션 키를 활용해서 점수를 정렬 키로 정렬해 탐색 범위를 줄일 수 있음
- 저장되는 월별 기간에 따라서 조회 범위가 몰리는 일이 발생할 수도 있음
- 분산 수집 방법을 여기서도 사용함 (파티션 수를 적절히 결정해야만 한다.)

## 💡 3. 전부 읽고 난 후기
이전 장이 어려워서 그런가, 예전에 보았던 내용이 기본 베이스로 있으니 확실히 더 잘 읽히는 느낌!
레디스 사랑해

## ❓ 4. 특별히 궁금했던 부분
- Redis hash ? 
- RDB는 읽기 쓰기에 한계가 명확하다..? (index를 내림차순으로 활용하는 방법)
- 동점자 처리가 조금 복잡한 상황이라면? 두개 세개씩 더 붙는 조건들