# 📚 스터디 템플릿

## 📖 1. 목차를 읽기 전에 든 생각
진짜 빠르고 진짜 정확한 서비스를 제공하기 위해선 우리가 알고 있는 CS지식에 대한 한계점을 얼마나 많이 극복했는지가 궁금합니당

## 📝 2. 내용 정리
### 1단계
- 100가지의 주식
- 10억건의 하루 주문
- 영업시간은 6.5시간
- QPS 는 43000
- 가용성 99.99%
- 최대 215000
- 주식 거래상에 각종 규제가 있음

### 2단계

#### 역할
- 브로커
  -개인 고객은 브로커를 통해서 증권을 거래하고 사용자 인터페이스를 제공받는다.
- 기관 고객
  - 전문 증권 거래 소프트웨어로 거래한다. 연기금은 거래량이 많고, 분할 주문은 수수료 리베이트가 가능하다.

#### 설계
- 고객이 브로커 웹 모바일로 주문한다.
- 브로커가 주문을 거래소에 전송한다.
- 주문이 클라이언트 게이트웨이로 거래소로 들어간다.
- 주문 관리자가 위험 관리자가 설정한 규칙에 따라 위험성 점검을 수행한다.
- 위험성 점검 과정을 통과한 주문에 지갑에 주문 처리 자금이 충분한지 확인한다.
- 주문이 체결 엔진으로 전송, 매수와  매도에 두개의 집행 생성, 동일한 결과가 나오도록 시퀀서로 정렬한다.
- 주문 집행을 클라이언트에 전송한다.
---
- 주문이 체결디ㅗ면 집행 기록 스트림을 만든다.
- 시장 데이터 게시 서비스는 이 데이터를 시장데이터로 사용해 호가 창과 봉차트를 구성한다.
- 시장 데이터는 실시간 분석 전용 스토리지에 저장된다.

#### 체결 엔진 
- 각 주식 심절에 대한 주문서 호가창을 유지 관리한다.
- 매수 주문과 매도 주문을 연결한다. 체결은 가능한 빠르게 처리되어야한다.

#### 시퀀서
- 체결 엔진에 주문을 전달하기 전에 순서 id를 붙여 보낸다.
- 입출력 시퀀서 두가지가 있고, 각각 고유한 순서를 유지한다.
- 메세지 큐 역할도 한다. (하나는 ㄴ체결 엔진에 메세지를 보내는 큐, 하나는 메세지를 관리자에게 회신하는 큐)

#### 주문 관리자
- 한쪽에서는 주문을 받고 다른 쪽에서는 집행 기록을 받는다.
- 주문에서는 위험성 검토, 추웁ㄴ한 자금이 있는지 확인, 주문을 시퀀서에게 전달 등의 절차가 이루어진다.
- 다양한 상태 관리를 해야한다. (보통 수만가지) => 이벤트 소싱을 주로 활용한다.

#### 클라이언트 게이트웨이
- 지연 시간에 가장 민감한 서비스 , 가벼워야 한다.
- 지연시간, 거래량, 보안 요구사항이 가장 중요하다.
- 매우 낮은 지연시강르 이ㅜ해 코로케이션 엔진을 실행한다. (브로커가 거래소 데이터 센터에서 임대한 거래 엔진 소프트웨어)
- 빛이 서버에서 서버로 이동하는데 걸리는 시간 정도의 지연시간 수준임

#### 보고 흐름
- 속도보다는 정확성과 규정 준수가 핵심이다.

#### API 설계
- 주문, 집행, 호가장 주문서, 가격 변동 이력, 등이 필요하다.
- 가장 먼저, 중요 거래 정보를 바로 DB에 저장하지 않는다. 
  - 메모리에서 먼저 거래를 체결하고 주문과 집행 기록은 하드디스크나 공유 메모리를 저장한다.
  - 그리고 빠른 복구를 위해서 시퀀서에 저장하고 db 보관은 장 마감 이후에 실행한다.
- 호가창은 가격 수준별로 정리, 가능한 O(1)의 시간 복잡도를 가지도록 한다.
  - 자료구조도 중요하다. 이중 연결 리스트로 변경해 모든 삭제 연산이 처리되도록 해야 한다.


### 3단계
하나의 슈퍼컴퓨터 수준의 거대 서버로 모든 것을 운영하기도 한다.

#### 성능
- 네트워크 및 디스크 사용량 감소
  - 가장 중요한 요소들만 가지고 전달될 수 있도록 한다. (지연시간이 생명). 심지어 로깅 조차도 뺀다.
  - 왕복 네트워크 지연 시간은 500마이크로 초. 컴포넌트가 많아지면 이마저도 1자리 수로 줄일 수 있음
  - mmap 이벤트 저장소를 활용한다.
- 순환문을 계속 폴링한다. 이때 순환문은 가장 중요한 작업만 시행하도록 한다.
- 요청을 특정 CPU 코어만을 활용하도록 해 컨텍스트 스위칭을 없앤다. 락을 사용할 필요도 경합도 없다.
  - 단, 스레드를 오래 점유하지 않도록 시간을 분석해 저장해야 한다.
- mmap
  - 파일을 프로세스 메모리에 매핑하는 posix호환 unix 시스템 콜을 의미한다.
  - /dev/shm은 메모리 기반 파일 시스템을 의미한다.

#### 이벤트 소싱
- 전통 어플리케이션은 상태를 DB에 유지하지만, 원인을 추적하기 어려움
- 이벤트 소싱처럼 과정을 추적할 수 있는 변경 불가능한 로그를 활용한다.
- 과정을 기록하고 있으므로 이를 되돌리는 과정도 이벤트 순서의 역순으로 재생하면 주문 상태를 복구 가능
- 주문 관리자 : 주문 상태를 관리하는 과정이 중요. 
  - 다른 컴포넌트가 주문 상태를 업데이트하거나 중앙화된 주문 관리자를 이용하면 지연시간이 길어질 수 있음
- 시퀀서가 없음
  - 모든 메세지가 동일한 이벤트 저장소를 활용. 그래서 시퀀스 쓰기를 이벤트 저장 이후에 하게 되면, 쓰기 경쟁이 일어남
  - 그래서 이벤트 저장소에 보내기 전에 순서대로 정렬한다. (유일한 쓰기)

#### 고가용성
- 하루에 8.67초를 넘으면 안된다.
- 주문 관리자나 체결 엔진처럼 상태를 관리해야 하는 서비스의 경우 사본 간에 데이터를 복사할 수 있어야 한다.(무상태와는 처리 방법이 다름)
- 대부분 단일 서버로 이루어져 있기 떄문에 주 부 체결 엔진을 확장 해야 한다.
- 여러 클러스터로 구성해야 하지만, 시간이 소요된다. (UDP로 통신해 전달 속도를 그나마 개선)

#### 결함 내성
- 부서버까지 다운되는 경우를 대비해 여러 데이터센터에 복제를 해둔다.
- 초기에는 문제가 생기면 수동 복구를 한다. 이제, 부 서버가 주 서버가 되는 기준에 대해서 설정을 해야 함
- 처음 리더에게 하트비트를 보내고, 답이 없으면 이제 다른 후보에게 하트비트를 보내고 투표를 요청
- 여러 팔로어가 후보가 된다면 분할 투표를 한다.새로운 선거를 시행
#### 복구 시간
- 복구 시간은 2등급 RTO처럼 피해가 최소화되도록 자동 복구가 가능해야 함
- 최소 서비스 수준을 유지하기 위해 성능 저하 전략을 정의한다.
- 손실 허용 범위를 가장 최소로 유지할 수 있어야 한다.

#### 시장 데이터 게시 및 서비스 최적화
- 일반적으로 어플리케이션에서 실시간으로 보여지는 데이터 결과나, 구글에서 보여주는 차트 결과는 시간 차이가 존재할 수 있음
- 다른 사이트에서도 보려면 봉차트 같응ㄴ 시스템이 자체적으로 구축되어야 하고, 결국 클라이언트도 더 많은 돈을 지불 한다.
- 링 버퍼를 활용해서 문제를 해결
  - 고정된 크기 큐를 가진다. 사전 할당이고 추가 삭제는 없다.
  - 락을 사용하지 않는다.

#### 시장 데이터의 공정한 배포
- 모든 수신자가 동시에 시장 데이터를 받도록 보장하는 것이 더 중요하다. 누가 먼저 받으면 공정성 문제 훼손
- 안정적 UDP의 멀티캐스트는 좋은 방법임
  - 하나의 출처에서 다양한 하위 네트워크 호스트로 보내는 방식이다. 다만, UDP는 신뢰성이 낮음

#### 코로케이션
- 브로커와 거래소 서버를 같은 곳에 두도록 한다.

## 💡 3. 전부 읽고 난 후기
- mmap
  - mmap 함수는 매핑할 메모리의 위치와 크기를 인자로 받습니다. 메모리에 매핑된 데이터는 파일 입출력 함수를 사용하지 않고 직접 읽고 쓸 수 있다는 장점이 있습니다.
  - https://12bme.tistory.com/225
- 정보를 가장 효율적으로 처리하기 위한 전략이 굉장히 인상적이었음. 
- 컨텍스트스위칭, 락, 문제를 애초에 발생시키지 않도록 설계, 이벤트 소싱, 메모리 사용 등 기존 방식과 확연한 차이가 돋보였음
- 갑자기 생각난 건데 무기 시스템 같은 경우는 함수의 뎁스를 4 이내로만 사용해야 하기 때문에 알고리즘을 굉장히 잘 해야한다고 들음

## ❓ 4. 특별히 궁금했던 부분
- 480p 선거 타이머가 타임아웃 된 팔로어가 후보가 된다..? 그전에 박동이 와야 후보가 되지 않을까?
- 이벤트 메모리를 관리하기에도 부담이 심하지 않을까? 메모리를 가장 짱짱하게 두어야 하는걸까? os튜닝이 필요?
- 데이터를 나중에 저장한다고 했는데, 하드에 저장되는 데이터는 어떤 방식으로 저장하는건가?
