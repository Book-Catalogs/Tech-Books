# 📚 스터디 템플릿

## 📖 1. 목차를 읽기 전에 든 생각
- 예전에 와디즈 관련 친구의 친구 추천 서비스를 봤는데 이런 연관관계와 관련된 이야기가 주가 될까?
- 이전 장과 마찬가지로 거리 기준해서 데이터를 선택해서 보여주면 되지 않을까 싶음

## 📝 2. 내용 정리

### 1단계 비즈니스 분석
- 내 위치를 기준으로 특정 반경을 통해 주변에 있는 친구를 파악해야 한다.
- DAU 1억, 통시 사용자 수 천만명을 가정한다.
- 나의 위치는 변화할 수 있다. 즉 이동 위치에 따른 주변 친구의 변화도 있어야 함
- 이동 이력도 생각해야 한다.
- 낮은 latency, 안정성이 필요, 대신 repl로 인한 데이터 정합성이 잠시 불일치해도 괜찮음

### 2단계 개략적 설계
- 위치정보는 모든 친구에게 전송해야함 -> 단순 http 요청으로는 한계가 있음
- 듕시 접속자 수가 1000만명에 육박하기 때문에 백엔드 서버만 두는 방법으로는 한계가 있다.

### 아키텍처
#### 양방향 위치정보 파악
- 우선 웹소켓을 활용한다. redis pub/sub을 활용해 친구들에게 내 위치정보를 알린다.
  - 검색 반경 내 친구 위치는 이 연결을 통해 클라이언트에게 전송된다.
  - 특정 사용자의 위치가 바뀌면 이 결과를 모든 친구의 웹소켓 연결 핸들러가 호출된다. 이 정보를 받아서 나와 친구와의 거리를 계산한다.
  - 웹소케 서버는 pub/sub에 새 위치를 발행한다.
  - 이 이벤트를 모든 구독자에게 broadcast. -> 수신한 사용자는 계산 -> 결과에 따라 보여줄지 여부를 결정한다.
- 현재 위치정보를 캐싱한다. (이동하지 않는다는 가정?)
  - 레디스의 ttl을 활용해 이 기능을 사용하다가 꺼지면 비활성 상태로 바뀌고 위치 정보는 캐시에서 삭제된다.
- 이동 이력 DB에 이력을 저장한다.
- 사용자 DB : 사용자 정보나 친구 관계를 활용하기 위한 DB
  - RDB나 NoSQL 모두 사용 가능
#### API 서버
- 사용자 DB : 사용자 정보나 친구 관계를 활용하기 위한 DB
- 실제 주변 친구를 파악하기 위한 서버가 필요하다.
#### DB 대신 Redis
- 위치정보를 DB에 저장하지 않는다. 레디스 캐시만을 활용
- 이유 1 : 사용자의 현재 위치만을 사용
- 이유 2 : 읽기 쓰기가 매우 빠름
- 이유 3 : TTL을 지원으로 활성상태가 아니면 자동 제거 가능(영속성 필요 없다)

#### 한계
- 쓰기 연산에 부하가 발생할 수 있음
- RDV에 샤딩이 들어가야할 수 도 있음

### 3단계 상세 설계
2단계처럼 개략적 설계는 가능할 수 있겠지만, 대규모 서비스이다보니 어느정도 한계가 존재할 수 있음

#### 단순한 아키텍처 (with 레디스 펍 섭)
- 레디스 펍 섭을 사용하는 이유는 채널을 만드는 비용이 저렴하다.
- 구독자가 없는 채널은 버려질 때도 부하가 없음
- 관계를 추적하기 위한 해시테이블 연결리스트는 아주 소량의 메모리만을 사용한다.
- 오프라인인 경우 쳬ㅕ자원은 전혀 사용하지 않는다.
- **'나'위주의 설계가 되어있어 친구가 내 상태를 관리하는게 아니라 내가 친구들의 상태를 관리한다.**
- 더 많은 메모리를 사용하지만, 메모리 병목이 되지는 않음. 하지만 CPU병목이 될 수 있음

#### CPU병목을 해결하기 위한 분산 레디스 펍 섭 클러스터 - 해시링
- 노드(서버)와 데이터 키를 모두 해시 함수를 사용해 동일한 값 범위로 매핑 (링 모양으로 전달)
- 데이터 키의 해시 값으로 해당 키보다 크거나 같은 가장 가까운 노드에 데이터를 할당
- 기존 데이터에 영향을 주지 않고 추가 및 삭제 가능
- 이 링 자체를 사본을 떠서 캐싱 목적으로 활용해도 된다.

#### 운영시 고려사항 - 노드 교체
- 해시 링 키에 있는 값을 갱신해 장애가 발생한 노드와 교체
- 이 소식은 모든 웹소켓 서버에 통지되고, 실행중인 연결 핸들러에게 새 펍섭 서버 채널을 다시 구독하도록 알림
- 이를 수신한 핸들러는 갖고있던 모든 채널을 해시 링과 대조해 구독 관계를 재설정한다.

#### 운영시 고려사항 - 친구가 많은 사람
- 수천명의 친구를 구독하는 사람의 구독 관계는 여러 웹소켓 서버에 분산되어 있어 부하에 무리가 없음
- 부하가 생기는 경우를 핫스팟(hotspot)이라고 한다.

## 💡 3. 전부 읽고 난 후기
- 생각보다 고려해야할 내용이 훨씬 많았고 어려웠다.
- 레디스가 왜 빠른지를 한번 공부해보는게 좋겠다. 단순히 메모리 기반이라고만 알고있지, 메모리 vs 디스크 비교도 필요할 듯
- 무상태 서버 : 클라이언트와 요청이 독립적으로 처리되며 이전 요청 상태를 저장하지 않음
- 유상태 서버 : 클라이언트와 상호작용을 유지 (세션이나 db에 저장, Ex 웹소켓)
- 레디스 펍섭 서버의 채널을 만드는과정 (왜 비용이 저렴한지)

## ❓ 4. 특별히 궁금했던 부분
- 단방향 관계의 연결은 조금 더 쉬울까?
- 수억명의 인플루언서의 관리는 어떻게 이루어질 수 있을까?
- 메모리를 많이 쓰면서 운영하는 서버의 비용은 과연 적절한 걸까?