# 📚 스터디 템플릿

## 📖 1. 목차를 읽기 전에 든 생각
S3를 쓰면 되지 왜 만들까..?

## 📝 2. 내용 정리
### 1단계
- 버킷 생성
- 객체 업로드 다운로드
- 객체 버전
- 버킷 내 객체 목록 출력 기능

### 2단계

#### 기본 구조
- 객체 저장소에 보관된 객체는 변겨잉 불가능
- 키 값 저장소 : URI가 키, 데이터는 값
- 읽기가 95%수준을 차지하고 있음
- 기본 파일 시스템의 아이노드와 유사 
  - 같은 폴더 내에서는 같은 이름의 파일이 존재할 수 없음
  - 이름은 아이노드 자료구조에 저장, 데이터는 디스크의 다른 위치에 보관된다.

#### 객체 다운로드
- 폴더 시스템을 지원하지는 않지만 버킷 이름과 객체 이름을 연결해 폴더 구조처럼 사용 가능

### 3단계
#### 데이터 저장소
업로드를 하면 객체 아이디를 반환, 다운로드시에는 객체 아이드를 붙여 요청하면 객체를 다운로드 할 수 있음
#### 데이터 라우팅
데이터 노드 클러스터에 접근하기 위해 RESTful, gRPC를 제공해서 정보를 가져다 줄 데이터 노드를 판단한다.
#### 배치 서비스 (batch아닌듯, 정리 의미인듯)
- 어느 데이터 노드에 데이터를 저장할 지 결정한다.
- 데이터 노드의 위치 저옵를 이용해 replica가 물리적으로 다른 위치에 배치
- heartbeat를 통해 15초 간격으로 서버가 살아있음을 확인하고 절반 이상 살아있으면 가동 하도록 한다.
#### 데이터 저장
각 객체를 개별 파일로 저장
   - 낭비되는 블록 수가 늘어날 수 있음
   - 아이노드 용량이 초과될 수 있음 (작은 객체를 큰 파일 하나로 모은다? 이미 존재하는 파일에 추가로 작성하기)
1. 다중화
- 계산이 필요 없어서 성능이 우월
- 데이터 복제에 집중되어 있어 쓰기 성능이 우월
- 읽기도 다중화 쪽의 성능이 우월하다.
2. 소거 코드
- 내구성이 상당히 높음. 페리티 라는 계산 식으로 일부 데이터에 대한 복원이 가능함.
#### 대용량 파일 업로드
- multipart upload : 큰 파일을 작은 파일로 쪼개서 업로드하고 복원한다.
- 조각 하나가 업로드 될 떄마다 ETag를 반환한다.
#### 쓰레기 수집
- 더이상 사용되지 않는 데이터에 할당된 저장 공간을 자동으로 회수한다.
- 사본에 할당된 저장공간을 회수하기도 한다.

## 💡 3. 전부 읽고 난 후기
아 어렵다 한번 더 읽어야겠다.


## ❓ 4. 특별히 궁금했던 부분
S3는 디렉토리 형태로 구현되어 있는줄 알았는데, 이것도 접두어 형태로 구성된 거일듯
#### 오브젝트 스토리지, 파일 스토리지, 블록 스토리지 차이
객체 스토리지 : 파일과 메타데이터를 같이 저장한다. 데이터를 고유한 id로 접근하고, 메타데이터 기반 검색이 가능하다. (비정형 데이터에 적합)
파일 스토리지 : 데이터를 디렉토리 파일로 저장한다. (계층적 구조, 사용자가 디렉토리와 파일 관리)
블록 스토리지 : 데이터를 고정된 크기의 블록으로 나누어 저장한다. 빠른 읽기 쓰기, 데이터 일부가 수정 가능하다.

#### 아이 노드란?
index-node
- 파일이나 디렉토리의 메타데이터를 저장하는데 사용
- 각 파일이나 디렉토리는 고유한 inode를 가진다. (소유자,그룹,권한, 시간 등을 저장)
- 파일 이름과 별도로 관리되고 디렉토리 이름은 inode의 포인터로 연결된다.
- 디스크 용량이 충분해도 아이노드가 부족하면 더이상 저장할 수 없다. 이걸 고려해야 함
  - inode사용량이 높은 디렉토리를 찾아 정리하는 등의 방법이 필요하다.

