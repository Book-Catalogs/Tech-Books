# 📚 스터디 템플릿

## 📖 목차를 읽기 전에 든 생각
- 도커의 기초에선 어떤 내용이 나올까?

## 📝 내용 정리
### 도커 이미지
- 컨테이너 형태로 소프트웨어를 배포하기 위해 필요한 모든 요소(코드, 라이브러리, 설정)을 실행할 수 있는 포멧
- 도커 컴포즈와는 다르게 단일 컨테이너를 구축할 수 있는 실행 파일
- 도커 허브와 같은 중앙 저장소에 저장되어 관리

### 도커 컨테이너
- 도커 이미지를 실행할 수 있는 인스턴스
- 내부에 운영체제 전부를 포함하지 않기 떄문에 가벼움
- 컨테이너는 도커 엔진이 설치되어 있는 호스트 운영체제를 이용함

### 도커 기초 명령어
- Docker 이미지는 여러개의 레이어로 구성된 파일 시스템 구조를 가진다. 각 레이어는 이전 레이어를 기반으로 쌓이고 이미지의 효율적인 저장과 배포가 가능하다.
```
├── Docker 데몬 (dockerd)
│   ├── Docker 이미지 (여러 개의 레이어로 구성)
│   │   ├── Base Layer (Ubuntu)
│   │   ├── Layer 1: 패키지 업데이트 (apt-get update)
│   │   ├── Layer 2: 애플리케이션 설치 (RUN npm install)
│   │   ├── Layer 3: 소스 코드 추가 (COPY . /app)
...
```

1. 도커 이미지 다운로드 : `docker image pull {이미지 이름:태그 이름}`
    - 태그명을 입력하지 않으면 자동으로 latest 태그가 적용됨
    - pull complete 메시지가 이미지 레이어 개수만큼 나타남 -> 해시값은 도커 이미지가 빌드될 때 생성된 ID 값임
    - `docker image pull {이미지 이름@DIGEST}`를 입력하면 해당 DIGEST의 이미지를 다운로드 할 수 있음
        - 여기서 DIGEST란? Docker 이미지의 고유한 식별자로 특정 이미지의 변조 여부를 확인하고 정확한 버전을 다운로드하는 데 사용함, 모든 레이어를 포함한 해시값이기도함

2. 도커 이미지 목록 확인 : `docker image ls`
    - REPOSITORY : 이미지 이름
    - TAG : 이미지 태그
    - IMAGE ID : 다운로드한 이미지의 ID 하지만 DIGEST값과는 다름
        - 다운로드할 때 DIGEST 값은 도커 레지스트라에 존재하는 이미지 DIGEST 값이고 해당 명령어의 결과값은 로컬에서 할당받은 IMAGE ID값에 해당
    - SIZE : 크기를 나타냄

3. 도커 컨테이너 실행 : `docker container run {이미지명}`
    - `docker run {이미지명}` -> `docker container run {이미지명}`로 변경

4. 도커 컨테이너 목록 확인 : `docker container ls`
    - 실행 중인 컨테이너만 보여줌
    - `-a` 옵션을 주면 정지 상태인 컨테이너 모두 확인할 수 있음
    - 각 컨테이너는 CONTAINER ID라는 것이 존재 하나의 이미지로 다수의 컨테이너를 생성할 수 있으므로 각 컨테이너는 CONTAINER ID를 가져야함
    - Exited(0)에서 0은 정상종료

5. 컨테이너 내부 접속 : `docker container run -it {컨테이너 이름}`
    - `-it` 옵션에서 i는 interactive의 줄임말 t는 tty의 줄임말

6. 컨테이너 종료 : `docker container stop {컨테이너 ID}` or `exit`
    - `-it` 옵션으로 들어가 있다면 exit를 통해 바깥이라면 `docker container stop {컨테이너 ID}`를 통해 종료
    - `docker container kill`을 입력하면 즉시 종료

7. 컨테아너 삭제 : `docker container rm {컨테이너 ID}`
    - 해당 컨테이너 ID로 컨테이너를 삭제할 수 있음

8. 이미지 삭제 : `docker image rm {이미지 이름}`
    - 해당 이미지 이름으로 이미지를 삭제할 수 있음

9. 도커 이미지 변경 : `docker container commit {컨테이너 ID} {이미지 이름}`
    - `-it`옵션으로 내부로 접속
    - net-tools를 다운받고 `ifconfig` 명령어를 입력해 컨테이너 IP 확인
    - 기존 터미널 말고 새로운 터미널 오픈
    - `docker container commit {컨테이너 ID} {이미지 이름}`를 이용해 해당 컨테이너에 새로운 이미지로 실행할 수 있음
    - exit

10. 호스트에서 컨테이너로 파일 전송 : `docker container cp {출발경로/보내고싶은파일} {도착 컨테이너:파일 저장 경로}`

11. 컨테이너에서 호스트로 파일 전송 : `docker container cp {출발 컨테이너:파일 저장 경로} {도착경로}`

### 도커 컨테이너 네트워크
    - 이미지로 컨테이너 실행 후 attach 명령어로 컨테이너 내부 접속 -> 컨테이너 IP 수집 가능 -> 다른 터미널에서 ifconfig를 이용해 도커 호스트의 네트워크 정보 확인 가능

### 도커 네트워크 확인
    - 터미널 2에서 `docker network ls`로 확인 가능
    - bridge 드라이버 : 기본 드라이버
    - host 드라이버 : 호스트 네트워크 인터페이스를 공유 `--network=host`를 사용하면 됨
    - none 드라이버 : 컨테이너 외부와의 통신이 불가능 네트워크 인터페이스를 가지지 않은 상태

### 도커 이미지 상세 구조
- 이미지 다운로드할때 결과창에 출력되는 digest는 이미지 인덱스에 해당
- 이미지 인덱스(digest)는 다수의 이미지 매니페스트로 구성
- 이미지 매니페스트는 다양한 운영체제 및 아키텍처에서 해당 이미지를 활용할 수 있도록 설정값과 다양한 레이어들을 제공
- 이미지 매니페스트는 Docker 이미지의 레이어 구조를 정의하고 해시값(DIGEST)를 기록하여 이미지 무결성을 보장함 그리고 이미 매니페스트에 있는 이미지를 한번 더 다운받으려 할때 다시 다운받지 않고 매니페스트에 있는 이미지를 가져다 쓰도록 함

### 도커 스토리지 개념
- 컨테이너가 삭제되면 컨테이너 내부에 존재하는 파일도 함께 사라짐 -> 컨테이너 내부에서 사용/생성되는 데이터가 컨테이너 실행 여부와 상관없이 유지 될 방법은 없을까?
    - 스토리지 사용
- 컨테이너에서 생성되는 데이터를 보존하기 위해 사용됨
- bind mount : 도커 호스트 디렉터리를 직접 공유하는 방식
- volume : 도커를 활용해 볼륨을 생성한 후 컨테이너의 디렉터리와 공유하는 방식
- tmpfs : 도커 호스트 메모리에 파일이 저장되는 방식 -> 컨테이너를 삭제하면 해당 파일로 함께 삭제
- 실습에서처럼 컨테이너를 정지시킨 후 다시 실행해도 앞서 생성했던 테이블이 여전히 살아있음

## 💡 전부 읽고 난 후기
- Docker의 이미지, 컨테이너, 네트워크, 스토리지 개념을 체계적으로 정리할 수 있었다.
- 이미지의 레이어 구조와 매니페스트 개념을 이해하면서 Docker가 어떻게 효율적으로 이미지를 저장하고 재사용하는지 알게 되었다.

## ❓ 특별히 궁금했던 부분
- 이미지 매니페스트에서 동일한 이미지 태그가 여러 아키텍처(amd64, arm64 등)를 지원할 때 특정 아키텍처의 이미지를 강제로 선택하는 방법이 있는가?
    - 호스트 OS를 따르기 때문에 아마 자동으로 다운로드가 되는것으로 알고있는데 만약 강제로 바꾸고 싶을때는 어떻게 해야하는것인가?

## ⏳ 독서 과정 기록
- **총 독서 시간**: 2시간
- **각 장별 소요 시간**:
  - Chapter 4: 2시간

## 🤔 이해도 점검 & 난이도 평가
- **어려웠던 부분 & 이유**:
  - 도커 매니패스트가 무엇인지 잘 몰랐다 왜냐면 도커 매니페스트가 어디서 어떻게 쓰이는지를 알아야 이게 이해가 가능할 것 같았다.

- **자신의 이해도를 점수로 표현하기 (5점 만점)**
  - Chapter 4: ⭐⭐⭐⭐☆ (4/5)

- **특별하게 깨달음을 얻은 부분**
  - Docker의 이미지가 단순한 실행 파일이 아니라 레이어 구조를 가진 파일 시스템이라는 점을 명확히 이해할 수 있었다.