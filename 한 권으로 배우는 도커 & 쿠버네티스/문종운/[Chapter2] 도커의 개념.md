# 📚 스터디 템플릿

## 📖 목차를 읽기 전에 든 생각
- 이 책을 읽게 된 계기 자체가 쿠버네티스에 대한 이해도를 높이기 위함이었다. 쿠버네티스를 이해하기 위해서는 기본적으로 컨테이어가 생기게 된 원인부터 하이퍼바이저와의 차이를 명확하게 이해하고, 그 기반 이론을 이해하기 위해서이다.
- 물리적인 환경의 OS에서 벗어나 논리적인 환경의 OS를 어떻게 구성하는지에 대한 개념을 이해하고, 강의에서 얻은 내용을 같이 정리해보자.
- 해당 책이 강의에서 본 내용을 서술한 책은 아니기에 부족한 점이 있는 것은 추가하고 디테일하게 설명된 부분은 가져가는 식으로 작성한다.

## 📝 내용 정리

## 네임스페이스
NameSpace는 **시스템 리소스를 분리해서 실행할 수 있도록 도와주는 기능**을 의미한다.  
컴퓨터 시스템에서 서로 다른 리소스를 구분하기 위한 식별 방법이다.

### 네임스페이스의 종류 예시
- PID: 프로세스 ID
- NET: 네트워크
- IPC: 프로세스 간 통신
- MNT: 마운트

## 컨테이너
컨테이너는 **소프트웨어를 배포할 때 필요한 코드, 라이브러리, 환경 설정 파일들을 한데 모아 격리시킨 후 실행가능한 패키지로 만든 것을 의미**한다.  
서로 다른 컨테이너는 격리된 환경에서 작동하므로 서로 충돌하지 않는다. 격리된 환경으로 최소 구성 요소로 분할하여 구축하기 때문에 MSA의 기반이 되기도 한다.

## 가상화 기술
실제로 존재하는 컴퓨터가 아니지만 실제로 컴퓨터가 존재하는 것처럼 보여주는 기술이다.
- 컴퓨터 안에서 컴퓨터를 또 실행하는 것
- 물리적인 컴퓨팅 환경에서 논리적인 컴퓨팅 환경을 만드는 것
을 의미한다.

## 가상화 기술의 종류
- 하이퍼바이저 기반 가상화
- 컨테이너 기반 가상화

### 하이퍼바이저 기반 가상화
하이퍼바이저는 단순히 하나의 프로그램이다. 가상화를 한다는 것은 실제 물리적인 컴퓨팅 환경에서 논리적인 컴퓨팅을 만들어내는 것이기에 논리적인 컴퓨팅 또한 하나의 프로세스로 볼 수 있다. 이때, **물리적인 하드웨어의 OS를 Host OS**라고 부르며, **가상화를 한 프로세스를 Guest OS**라고 부른다.

가상화 컴퓨터에서 발생하는 명령은 논리적인 컴퓨팅 영역의 명령이고, 최종적으로는 HostOS의 명령으로 변환되어 실행되어야만 한다. 이때, 가상화 컴퓨터에서 발생하는 명령을 **Hypervisor 명령**이라고 부른다.

즉, 하이퍼바이저는 서로 다른 OS의 System call (Kernal call)을 호출 할 수 있도록 도와주는 어댑터이다.

### 컨테이너 기반 가상화
컨테이너 기반 가상화는 LXC(Linux Containers) 기술에서 출발했다.
- 단일 컨트롤 호스트 상에서 여러 개의 고립된 리눅스 시스템을 실행 할 수 있다.
- 커널의 Namespace와 CGroups를 사용하여, 커널의 격리 기능을 사용한다.

#### 단일 컨트롤 호스트
- Host OS를 의미한다.

#### CGroups
- 프로세스가 사용하는 메모리와, CPU, 하드디스크, 네트워크 전송량과 같은 사용량을 관리한다.

위와 같이 NameSpace와 CGroups를 합쳐진 것은 컨테이너라고 부른다.

## 하이퍼바이저 vs 컨테이너
- 하이퍼바이저는 각각의 Guest OS가 독립적인 커널을 가지기 때문에 구성과 실행하기까지의 시간이 오래걸리고 Guest OS가 차지하는 오버헤드가 크다. 하지만, 독립적으로 Guest OS가 존재하기 때문에 더 안전하다.

- 반면, 컨테이너는 Host OS의 커널을 공유하기 때문에 하이퍼바이저에 비해 실행 속도가 상당히 빠르고 구성이 간단하다. 단점으로는 하이퍼바이저와 같이 Kernal Call을 하기 위한 Adapter가 별도로 없기 때문에 다른 종류의 OS를 실행 할 수 없다.

## 컨테이너 플랫폼
컨테이너 플랫폼은 컨테이너를 생성하고 관리하는 기능을 제공하는 소프트웨어이다. 도커는 컨테이너 플랫폼 중 한 종류이다.
컨테이너 플랫폼은 컨테이너 엔진, 컨테이너 런타임으로 구성되어 있다.

### 컨테이너 엔진
컨테이너 엔진은 사용자의 요청을 받아서 컨테이너를 관리해주는 역할을 한다.

### 컨테이너 런타임
컨테이너 런타임은 직접 커널과 통신하면서 실제로 격리된 공간을 만드는 역할을 한다. 이러한, 컨테이너 런타임은 CRI(Container Runtime Interface)를 구현한 구현체가 컨테이너 런타임이다. 해당 인터페이스를 구현한 어떤 컨테이너 런타임이든 사용 할 수 있다.

## 도커
도커는 Client-Server 모델로 동작하며, 도커 클라이언트는 docker-cli 라고 부른다. 도커 클라이언트는 dockerd API를 활용해 명령을 내리는데, 여기서 dockerd는 도커 데몬으로 백그라운드에서 실행되는 데몬 프로세스이다. 실제로 API를 호출해서 컨테이너를 관리 할 수 있으나, API만 보고는 편히 실행하기 어렵기에 Docker Cli가 API를 편히 사용 할 수 있도록 Convert 를 수행한다.

Dockerd API는 도커 엔진 API에서 확인이 가능하다.
[도커 엔진 API 문서](https://docs.docker.com/engine/api/v1.48/)

## 도커의 구조

### 도커 클라이언트
- 도커메 영령을 내릴 수 있는 CLI 도구를 의미힌다. 도커 Client를 사용하여, 컨테이너, 이미지, 볼륨 등을 관리 할 수 있다.
### 도커 호스트
- 도커를 설치한 서버 혹은 가상머신. 물리 서버가 될 수도 있고 가상 서버가 될 수도 있다.
### 도커 레지스트리
- 도커 이미지를 저장하거나 배포하는 시스템, Public Repository와 Private Repository가 있다. 도커 허브는 도커 레지스트리의 한 종류이다.

## 이미지
서버에서 어떠한 프로그램이 프로세스가 되기 위해서는 세 가지 도구가 필요하다. 
- OS
- 프로그램이 실행되기 위해서 필요한 구성요소(런타임 도구 등)
- 실행시킬 프로그램

이미지는 특정 시점의 파일 시스템을 저장한 압축 파일이다. 이미지에는 소프트웨어가 필요한 모든 요소를 압축해서 저장하며, 이미지는 윈도우에서 사용하는 백업 기능과 동일하다. (스냅샷과 유사하다.)

## 이미지의 메타데이터
메타데이터가 주 데이터의 데이터를 의미하는 것처럼 이미지의 메타데이터는 이미지의 서브 데이터이다. 
이미지의 메타데이터에는 Id, RepoTags, Env, Cmd, Size등등 여러가지가 있다.  
`docker image inspect {imageName}` 명령어를 통해 이미지의 메타데이터를 확인 할 수 있다.

## 컨테이너
- 실행 상태의 이미지를 의미하며 한 개의 이미지는 여러 개의 컨테이너로 실행 될 수 있는 1 : N의 관계이다.
- 기존 OS에서 프로그램을 실행 할 때 프로세스가 되듯이 컨테이너로 실행했을 때 CPU, MEMORY 등의 리소스를 격리된 공간에서 사용하게 된다.
- 실행 시에는 이미지를 복사해 격리된 디스크 공간을 생성한다.

## 💡 전부 읽고 난 후기
- 책을 다 읽고 난 후 느낀 점, 배우게 된 점, 아쉬운 점을 자유롭게 적어주세요.
- 전체적인 평가나 적용하고 싶은 점도 포함될 수 있습니다.

## ❓ 특별히 궁금했던 부분
- 읽으면서 생겼던 의문이나 더 탐구하고 싶은 부분을 정리합니다.
- 팀원들과 논의하고 싶은 내용을 포함해도 좋습니다.

## ⏳ 독서 과정 기록
- **총 독서 시간**: 3시간
- **각 장별 소요 시간**:
  - Chapter 2: 1시간

## 🤔 이해도 점검 & 난이도 평가
- **어려웠던 부분 & 이유**:
  - 처음 볼 때에는 하이퍼바이저와 컨테이너의 가장 큰 차이를 OS의 유무로만 생각하고 있었다.
  - Host OS와 Guest OS의 차이를 명확하게 이해하고, 도커와 하이퍼바이저의 장단점을 이해하게 되면서 컨테이너의 개념을 이해하게 되었다.

- **자신의 이해도를 점수로 표현하기 (5점 만점)**
  - Chapter 2: ⭐⭐⭐⭐⭐ (5/5)

- **특별하게 깨달음을 얻은 부분**
  - 하이퍼바이저에서 HostOS에서 어떻게 GuestOS에서의 명령을 실행하는지에 대한 개념이 중요했던 것 같다.
  - 결국, 물리적인 환경에서 가상의 환경이 띄워지다보니 최종적으로는 물리적으로 존재하는 CPU, Network, Memory와 같은 리소스를 사용해야 하는데 OS마다 다르게 구성되어있는 System Call을 호출 할 수 있도록 Adapter 역할을 해준다는 것이 핵심 개념인 것 같다.
