# 📚 스터디 템플릿

## 📖 목차를 읽기 전에 든 생각
- 도커 네트워크, 스토리지 관련해서는 잘 모르는데 이번 기회에 확실히 알아가고 싶다.

## 📝 내용 정리
### 도커 아키텍처
<img src="https://github.com/user-attachments/assets/1d57f2dc-4c08-49c4-a393-f42bb5817171" width="50%"/>

- Docker 클라이언트  
  - `docker run` 등의 명령을 실행하면 클라이언트가 이를 `dockerd`(Docker 데몬)로 전달하여 처리함  
  - Docker 명령어는 Docker API를 사용하며, 하나의 클라이언트가 여러 데몬과 통신 가능  
- Docker 데몬  
  - Docker API 요청을 수신하고 이미지, 컨테이너, 네트워크, 볼륨 등 Docker 객체를 관리  
  - 다른 Docker 데몬과도 통신하여 서비스를 관리할 수 있음  
- Docker 레지스트리  
  - Docker 이미지를 저장하는 공간  
  - 기본적으로 Docker Hub에서 이미지를 검색하며, 필요하면 개인 레지스트리도 사용 가능  
- Docker 객체  
  - 이미지: 컨테이너를 생성하는 읽기 전용 템플릿  
  - 컨테이너: 실행 가능한 이미지의 인스턴스  

### Docker 이미지 & 컨테이너  
- 컨테이너란?  
  - 애플리케이션을 코드 + 모든 종속성과 함께 패키징하여 다른 환경에서도 일관되게 실행할 수 있도록 만든 소프트웨어 단위  
- Docker 컨테이너 이미지란?  
  - 실행에 필요한 코드, 런타임, 시스템 도구, 라이브러리, 설정 등을 포함한 독립 실행형 패키지  
  - 이미지는 실행될 때 컨테이너가 됨  
- 이미지의 중요한 원칙  
  - 이미지는 변경할 수 없음. 수정하려면 새 이미지를 생성해야 함  
  - 컨테이너 이미지는 레이어(layer) 구조로 이루어져 있으며, 각 레이어는 파일 변경 사항을 나타냄  

### Docker 이미지 레이어 & Dockerfile  

<img src="https://github.com/user-attachments/assets/0bf88323-2562-4639-b166-983a526abb31" width="50%"/>

- Docker 이미지는 레이어(layer)로 구성됨  
  - 각 레이어는 Dockerfile 빌드 명령의 결과  
  - 이전 레이어에 대한 변경 사항(파일 추가, 수정, 삭제)을 포함  
- Dockerfile  
  - 컨테이너 이미지를 자동 생성하기 위한 명령어가 포함된 텍스트 파일  
  - 모든 종속성을 포함하여 애플리케이션을 실행할 준비가 된 이미지를 만듦  
- 참고: [Docker 레이어 캐시 효율적으로 사용하기](https://medium.com/@hee98.09.14/docker-layer%EC%99%80-cache-574c12a1e9f7)  

### 도커 기초 명령어
- 도커 이미지 다운로드: ```docker image pull {이미지 이름:태그 이름}```
  - 태그명을 입력하지 않으면 자동으로 latest 태그 적용
- 도커 이미지 목록 확인: ```docker image ls```
- 도커 컨테이너 실행: ```docker container run {이미지명}```
- 도커 실행 중인 컨테이너 목록 확인: ```docker container ls```
- 도커 실행/중지 중인 컨테이너 목록 확인: ```docker container ls -a```
- 컨테이너 내부 접속: ```docker container run -it {이미지명}```
  - -it 옵션을 활용하면 가상 터미널을 통해 키보드 입력을 표준 입력으로 컨테이너에 전달할 수 있다.
- 컨테이너 종료: ```docker container stop {컨테이너 ID}```
  - 약 10초 후 컨테이너 종료
  - ```docker container kill {컨테이너 ID}``` 명령어를 입력하면 해당 컨테이너가 즉시 종료
- 실행 중인 컨테이너 접속: ```docker container attach {컨테이너 ID}```
- 컨테이너 삭제: ```docker container rm {컨테이너 ID}```
- 이미지 삭제: ```docker image rm {이미지 ID}```
- 실행 중인 컨테이너를 새로운 이미지로 생성: ```docker container commit {컨테이너 ID} {새로운 이미지명}```

### 도커 컨테이너 네트워크
- 도커 네트워크 확인:  ```docker network ls```
- 드라이버
  - bridge: 기본 네트워크 드라이버. 드라이버를 지정하지 않으면 이것이 생성하는 네트워크 유형. 브리지 네트워크는 일반적으로 애플리케이션이 동일한 호스트의 다른 컨테이너와 통신해야 하는 컨테이너에서 실행될 때 사용.
  - host: 컨테이너와 Docker 호스트 간의 네트워크 격리를 제거하고 호스트의 네트워킹을 직접 사용
  - none: 호스트 및 다른 컨테이너에서 컨테이너를 완전히 분리
- 참고: https://docs.docker.com/engine/network

### 도커 스토리지
- 기본적으로 컨테이너 내부에 생성된 모든 파일은 읽기 전용, 변경 불가능한 이미지 레이어 위에 있는 쓰기 가능한 컨테이너 레이어에 저장된다. 컨테이너 레이어에 쓰여진 데이터는 컨테이너가 파괴되면 유지되지 않는다.
- Docker는 컨테이너의 쓰기 가능한 계층 외부에 데이터를 저장하기 위해 다음 유형의 스토리지 마운트를 지원한다.
  - 볼륨: Docker 데몬이 관리하는 영구 저장 메커니즘
    - 볼륨은 이를 사용하는 컨테이너가 제거된 후에도 데이터를 유지한다. 볼륨 데이터는 호스트의 파일 시스템에 저장되지만 볼륨의 데이터와 상호 작용하려면 볼륨을 컨테이너에 마운트해야 한다.
    - 볼륨은 성능이 중요한 데이터 처리 및 장기 저장 요구 사항에 이상적이다. 저장 위치가 데몬 호스트에서 관리되므로 볼륨은 호스트 파일 시스템에 직접 액세스하는 것과 동일한 원시 파일 성능을 제공한다.
  - 바인드 마운트: 호스트 시스템 경로와 컨테이너 사이에 직접 링크를 생성하여 호스트의 어느 곳에 저장된 파일이나 디렉토리에 액세스할 수 있도록 한다.
    - Docker에 의해 격리되지 않으므로 호스트의 비 Docker 프로세스와 컨테이너 프로세스가 모두 마운트된 파일을 동시에 수정할 수 있다.
    - 컨테이너와 호스트 모두에서 파일에 액세스할 수 있어야 하는 경우에 사용하면 좋다.
  - tmpfs 마운트: 파일을 호스트 머신의 메모리에 직접 저장하여 데이터가 디스크에 기록되지 않도록 한다.
    - 이 스토리지는 일시적이다. 즉, 컨테이너가 중지되거나 재시작되거나 호스트가 재부팅되면 데이터가 손실된다.
    - 중간 데이터 캐싱, 자격 증명과 같은 민감한 정보 처리 또는 디스크 I/O 감소와 같이 일시적인 메모리 내 스토리지가 필요한 시나리오에 적합하다.

## 💡 전부 읽고 난 후기
- 도커의 기본적인 사용 방법에 대해서 알게 된 느낌이다.

## ❓ 특별히 궁금했던 부분
- 이 책에서는 없었고, Spring 테스트 컨테이너를 어떻게 사용하는지 궁금해졌다.

## ⏳ 독서 과정 기록
- **총 독서 시간**: 1시간 20분

## 🤔 이해도 점검 & 난이도 평가
- **어려웠던 부분 & 이유**:
  - 크게 없었다.

- **자신의 이해도를 점수로 표현하기 (5점 만점)**
  - Chapter 4: ⭐⭐⭐⭐☆ (4/5)

- **특별하게 깨달음을 얻은 부분**
  - 컨테이너를 다른 컨테이너에서 액세스할 수 있도록 하려면 컨테이너의 포트를 게시할 필요가 없고, 컨테이너를 동일한 네트워크에 연결하여 컨테이너 간 통신을 활성화한다.
  - 기본적으로 컨테이너를 만들거나 실행할 때 컨테이너는 외부 세계에 포트를 노출하지 않는다. --publish 또는 -p플래그를 사용하여야 외부의 서비스에서 포트를 사용할 수 있다. 
